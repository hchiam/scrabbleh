<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>scrabbleh</title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/hchiam/css-boilerplate@7.0.0/style.css"
      integrity="sha384-4LyMgnYb2AiZtfGx9DmU1yIah53F9unFaCNv8tmbRTycOKKEfY1VleH71ezkUOT8"
      crossorigin="anonymous"
    />
    <style>
      :root {
        --cell-size: max(5vmin, 3rem);
        --grid-gap: 2px;
        --z-submitContainer: 3;
        --z-piece: 2;
        --z-cell-focused: 1;
      }
      body {
        padding-block-start: 1rem;
        padding-block-end: 2rem;
        padding-inline: 1rem;
        max-height: 100dvh;
        display: flex;
        flex-direction: column;
      }
      button {
        cursor: pointer;
      }
      #submitContainer {
        /* position: fixed;
        top: 0;
        left: 0;
        padding: 1rem;
        z-index: var(--z-submitContainer);
        display: flex;
        gap: 1rem; */
      }
      #submit.haveCandidate,
      #cancel.haveCandidate,
      .cell.candidate {
        outline: var(--grid-gap) solid var(--accent-colour);
        @media (prefers-reduced-motion: no-preference) {
          animation: haveCandidate 1s infinite alternate;
        }
      }
      .cell.candidate {
        outline-width: calc(var(--grid-gap) / 2);
      }
      @keyframes haveCandidate {
        to {
          background: maroon;
          color: white;
        }
      }
      #pieces {
        /*margin-block-start: 2.5rem;*/ /* so #submitContainer doesn't cover top */
        margin-block-start: 1rem;
        margin-block-end: 1rem;
      }
      .piece {
        width: var(--cell-size);
        height: var(--cell-size);
        margin: var(--grid-gap);
        display: inline-flex;
        justify-content: center;
        align-items: center;
        font-family: monospace;
        font-size: 1rem;
        font-weight: bold;
        z-index: var(--z-piece);
      }
      .piece.currentPiece {
        background: var(--accent-colour);
        color: black;
      }
      #gameBoard {
        display: grid;
        grid-template-columns: repeat(15, var(--cell-size));
        grid-gap: var(--grid-gap);
        overflow: auto;
      }
      .cell {
        width: var(--cell-size);
        height: var(--cell-size);
        background: var(--background, #978967);
        color: var(--color, #fff);
        border-radius: 0;
        display: inline-flex;
        justify-content: center;
        align-items: center;
        text-align: center;
        vertical-align: middle;
        line-height: var(--cell-size);
        font-family: monospace;
        font-size: 1rem;
        font-weight: bold;
        outline: calc(var(--grid-gap) / 2) solid white;
      }
      .cell:focus,
      .cell:hover {
        background: lightgrey !important;
        color: black !important;
        box-shadow: 0 0 20px black;
        z-index: var(--z-cell-focused);
      }
      .cell.currentCell {
        background: var(--accent-colour) !important;
        color: black !important;
      }
      .cell:not(:empty) {
        background: rgb(50, 50, 50);
        color: white;
        pointer-events: none;
      }
    </style>
    <style id="dynamicStyle"></style>
    <script
      type="module"
      src="https://www.gstatic.com/firebasejs/10.10.0/firebase-app.js"
    ></script>
    <script
      type="module"
      src="https://www.gstatic.com/firebasejs/10.10.0/firebase-firestore.js"
    ></script>
    <script
      src="https://code.jquery.com/jquery-3.7.1.min.js"
      integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo="
      crossorigin="anonymous"
    ></script>
  </head>
  <body>
    <div id="submitContainer">
      <button id="submit">submit</button>
      <button id="cancel">cancel</button>
      <button id="goToGameId">go to game ID:</button>
      <input id="gameId" placeholder="game ID" />
    </div>
    <div id="pieces"></div>
    <div id="gameBoard"></div>
    <script type="module">
      // TODO: Add SDKs for Firebase products that you want to use
      // https://firebase.google.com/docs/web/setup#available-libraries
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.10.0/firebase-app.js";
      // import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.10.0/firebase-analytics.js";
      import {
        getFirestore,
        collection,
        addDoc,
        query,
        where,
        getDocs,
        onSnapshot,
        doc,
        updateDoc,
        deleteDoc,
      } from "https://www.gstatic.com/firebasejs/10.10.0/firebase-firestore.js";

      // For Firebase JS SDK v7.20.0 and later, measurementId is optional
      const firebaseConfig = {
        apiKey: "AIzaSyBupDhYe5qrcd6WRqa1Pek1XDIq-xFzBDE",
        authDomain: "scrabbleh-57234.firebaseapp.com",
        projectId: "scrabbleh-57234",
        storageBucket: "scrabbleh-57234.appspot.com",
        messagingSenderId: "398177698307",
        appId: "1:398177698307:web:294e7448a71edab2040436",
        measurementId: "G-0297WR3Q99",
      };

      // Initialize Firebase
      const app = initializeApp(firebaseConfig);
      const db = getFirestore(app);

      const red = new Set([0, 7, 14, 105, 119, 210, 217, 224]);
      const pink = new Set([
        16, 32, 48, 64, 28, 42, 56, 70, 196, 182, 168, 154, 208, 192, 176, 160,
      ]);
      const yellow = new Set([112]);
      const lightBlue = new Set([
        3, 11, 36, 38, 45, 52, 59, 92, 96, 98, 102, 108, 116, 122, 126, 128,
        132, 165, 172, 179, 186, 188, 213, 221,
      ]);
      const cornflowerBlue = new Set([
        20, 24, 76, 80, 84, 88, 136, 140, 144, 148, 200, 204,
      ]);
      const allPieces = {
        "?": 2,
        E: 12,
        A: 9,
        I: 9,
        O: 8,
        N: 6,
        R: 6,
        T: 6,
        L: 4,
        S: 4,
        U: 4,
        D: 4,
        G: 3,
        B: 2,
        C: 2,
        M: 2,
        P: 2,
        F: 2,
        H: 2,
        V: 2,
        W: 2,
        Y: 2,
        K: 1,
        J: 1,
        X: 1,
        Q: 1,
        Z: 1,
      };
      const dynamicStyle = $("#dynamicStyle");
      const submit = $("#submit");
      const cancel = $("#cancel");
      const gameId = $("#gameId");
      const pieces = $("#pieces");
      const gameBoard = $("#gameBoard");

      let currentGameFirebaseId = "";
      let gameBoardString = " ".repeat(15 * 15);

      window.onload = async function initializeOnLoad() {
        await setupRealtimeUpdates();
        listenForBroadcasts();
        initSubmit();
        initCancel();
        goToGameId();
        initPieces(Object.keys(allPieces).slice(0, 7));
        initGameBoard();
      };

      function initSubmit() {
        submit.on("click", async () => {
          const candidateRowOrColumn = [...gameBoard.find(".cell")].filter(
            (el) => $(el).css("opacity") !== "0.5"
          );
          const candidateLetters = candidateRowOrColumn.map(
            (el) => $(el).text() || " "
          );
          const candidateLetterChain = candidateLetters.join("").trim();
          if (candidateLetterChain.includes(" ")) {
            alert(
              `The letters must form a chain. \nHit cancel to try again. \n\n"${candidateLetterChain}"`
            );
            return;
          }

          // actually submit:
          gameBoardString = [...gameBoard.find(".cell")]
            .map((x) => $(x).text() || " ")
            .join("");
          await updateGame(currentGameFirebaseId, gameBoardString, "myTurn");

          dynamicStyle.text("");
          gameBoard
            .find(".candidateFirstLetter, .candidate")
            .removeClass("candidateFirstLetter")
            .removeClass("candidate");

          cancel.add(submit).removeClass("haveCandidate");
          submit.text("submit");
          cancel.text("cancel");
        });
      }

      function initCancel() {
        cancel.on("click", () => {
          cancel.add(submit).removeClass("haveCandidate");
          submit.text("submit");
          cancel.text("cancel");
          const candidateLetterCells = gameBoard.find(".candidate");
          const candidateLetters = candidateLetterCells.text().split("");
          candidateLetterCells.each((i, el) => $(el).text(""));
          initPieces(candidateLetters);
          dynamicStyle.text("");
          gameBoard
            .find(".candidateFirstLetter, .candidate")
            .removeClass("candidateFirstLetter")
            .removeClass("candidate");
        });
      }

      function goToGameId() {
        $("#goToGameId").on("click", async () => {
          const gameID = gameId.val();
          if (!gameBoard.text()) {
            await deleteGame();
          }
          await fetchGameByCustomId(gameID);
        });
      }

      function initPieces(lettersToAdd) {
        let htmlString = "";
        lettersToAdd.forEach((letter, count) => {
          htmlString += `<button class="piece">${letter}</button>`;
        });
        pieces.append(htmlString);
        pieces
          .find(".piece")
          .off("click")
          .on("click", (event) => {
            const currentPiece = $(event.target);
            if (currentPiece.hasClass("currentPiece")) {
              pieces.find(".currentPiece").removeClass("currentPiece");
            } else {
              pieces.find(".currentPiece").removeClass("currentPiece");
              currentPiece.addClass("currentPiece");
            }
            gameBoard.find(".currentCell").removeClass("currentCell");
          });
      }

      function initGameBoard() {
        let htmlString = "";
        for (let i = 0; i < gameBoardString.length; i++) {
          let style = "";
          if (red.has(i)) {
            style = `style="--background:red;--color:white;"`;
          } else if (pink.has(i)) {
            style = `style="--background:pink;--color:black;"`;
          } else if (yellow.has(i)) {
            style = `style="--background:yellow;--color:black;"`;
          } else if (lightBlue.has(i)) {
            style = `style="--background:lightBlue;--color:black;"`;
          } else if (cornflowerBlue.has(i)) {
            style = `style="--background:cornflowerBlue;--color:white;"`;
          }
          const cellValue = gameBoardString[i].trim() ? gameBoardString[i] : "";
          htmlString += `<button data-i="${i}" class="cell" ${
            style ? style : ""
          }>${cellValue}</button>`;
        }
        gameBoard.empty().append(htmlString);
        gameBoard
          .find(".cell")
          .off("click")
          .on("click", (event) => {
            const currentCell = $(event.target);
            if (currentCell.hasClass("currentCell")) {
              gameBoard.find(".currentCell").removeClass("currentCell");
              return;
            }
            gameBoard.find(".currentCell").removeClass("currentCell");
            currentCell.addClass("currentCell");
            const currentPiece = $(".piece.currentPiece");
            if (currentPiece.length) {
              animateMove(currentPiece, currentCell);
              currentCell.text(currentPiece.text());

              currentCell.addClass("candidate");
              const addedOnePieceAlready =
                $("#submit").hasClass("haveCandidate");
              if (!addedOnePieceAlready) {
                currentCell.addClass("candidateFirstLetter");
              }

              currentPiece.removeClass("currentPiece");
              currentPiece.remove();
              currentCell.removeClass("currentCell");
              const i = currentCell.data("i");
              const row = Math.floor(i / 15);
              const column = i % 15;
              const validColumn = `:nth-of-type(15n+${column + 1})`;
              const validRow = `:nth-of-type(n+${
                1 + row * 15
              }):not(:nth-of-type(n+${16 + row * 15}))`;
              if (addedOnePieceAlready) {
                // handle adding only a row XOR a column
                const firstCandidate = gameBoard.find(".candidateFirstLetter");
                const firstCandidateI = firstCandidate.data("i");
                const firstCandidateRow = Math.floor(firstCandidateI / 15);
                const firstCandidateColumn = firstCandidateI % 15;
                const isInSameRow = row === firstCandidateRow;
                const isInSameColumn = column === firstCandidateColumn;
                if (isInSameRow) {
                  dynamicStyle.text(
                    `.cell:not(${validRow}) { pointer-events: none; opacity: 0.5; }`
                  );
                } else if (isInSameColumn) {
                  dynamicStyle.text(
                    `.cell:not(${validColumn}) { pointer-events: none; opacity: 0.5; }`
                  );
                }
              } else {
                // first piece placed lets you place next in a row or a column
                dynamicStyle.text(
                  `.cell:not(${validColumn}):not(${validRow}) { pointer-events: none; opacity: 0.5; }`
                );
                submit.text("submit?").addClass("haveCandidate");
                cancel.text("cancel?").addClass("haveCandidate");
              }
            }
          });
      }

      function animateMove(
        originElement,
        destinationElement,
        animationTime = 100
      ) {
        destinationElement.css("visibility", "hidden");
        const original = $(originElement);
        const originalMarginLeft = parseInt(original.css("marginLeft"));
        const originalMarginTop = parseInt(original.css("marginTop"));
        const originPosition = original.position();
        originPosition.left = originPosition.left + originalMarginLeft;
        originPosition.top = originPosition.top + originalMarginTop;
        const originalWidth = original.outerWidth();
        const originalHeight = original.outerHeight();
        const destinationPosition = $(destinationElement).position();
        const destinationWidth = $(destinationElement).outerWidth();
        const destinationHeight = $(destinationElement).outerHeight();
        const temp = original.clone();
        $("body").append(temp).prop("inert", true);
        temp.addClass("temp");
        temp.addClass("disable-hover").find("*").css({ pointerEvents: "none" });
        temp
          .css({
            position: "fixed",
            zIndex: 1,
            width: originalWidth,
            height: originalHeight,
          })
          .offset(originPosition)
          .animate(
            {
              left: destinationPosition.left,
              top: destinationPosition.top,
              width: destinationWidth,
              height: "auto", // destinationHeight,
            },
            animationTime
          );
        setTimeout(() => {
          temp.remove();
          $(destinationElement).css("visibility", "visible");
          $("body").prop("inert", false);
        }, animationTime * 10);
      }

      async function getWordData(word) {
        const url = `https://api.dictionaryapi.dev/api/v2/entries/en/${word}`;
        return await fetch(url)
          .then((x) => x.json())
          .then((x) => {
            const errorTitle = "No Definitions Found";
            const foundEntry = !("title" in x) || x.title.includes(errorTitle);
            const firstDefinition = foundEntry
              ? `First definition:  \n${x[0].meanings[0].definitions[0].definition}`
              : "";
            return { isValid: foundEntry, firstDefinition: firstDefinition };
          });
      }

      async function setupRealtimeUpdates() {
        const gameID = gameId.val();
        if (gameID) {
          await fetchGameByCustomId(gameID);
        } else {
          currentGameFirebaseId = await createGame();
        }
      }

      async function fetchGameByCustomId(customId) {
        try {
          const gamesCol = collection(db, "games");
          const q = query(gamesCol, where("id", "==", customId));
          const querySnapshot = await getDocs(q);
          if (!querySnapshot.empty) {
            // Assuming 'id' is unique, there should only be one doc
            if (querySnapshot.docs.length > 1) {
              console.warn("Multiple games found with the same custom ID.");
            }
            const gameDoc = querySnapshot.docs[0];
            const gameData = gameDoc.data();
            console.log("Game data: ", gameData);
            currentGameFirebaseId = gameDoc.id;
            console.log("currentGameFirebaseId", currentGameFirebaseId);
            gameBoardString = gameData.gameBoard;
            // Setting up real-time updates for the fetched game
            setupRealtimeUpdatesForGameDoc(gameDoc.ref);
          } else {
            console.log("No game found with the custom ID: ", customId);
          }
        } catch (error) {
          console.error("Error fetching game by custom ID: ", error);
        }
      }
      function setupRealtimeUpdatesForGameDoc(gameDocRef) {
        onSnapshot(gameDocRef, (docSnapshot) => {
          if (docSnapshot.exists()) {
            const gameData = docSnapshot.data();
            console.log("Real-time game data: ", gameData);
            gameBoardString = gameData.gameBoard;
            initGameBoard();
          } else {
            console.log("Could not set up real-time updates for a game doc.");
          }
        });
      }

      async function createGame() {
        try {
          // Reference to the 'games' collection
          const gamesCol = collection(db, "games");
          const randomId = getRandomId();
          gameId.val(randomId);
          // Add a new document with Firestore-generated unique ID
          const gameRef = await addDoc(gamesCol, {
            id: randomId,
            createdAt: new Date(),
            players: [],
            whoseTurn: "",
            gameBoard: " ".repeat(15 * 15),
          });
          console.log("Game created with ID: ", gameRef.id);
          return gameRef.id; // Returns the generated game ID
        } catch (error) {
          console.error("Error creating game: ", error);
          alert(error);
        }
      }

      function getRandomId() {
        // TODO: guarantee unique? otherwise use long firebase string
        return getDayOfYear() + String(new Date().getTime()).slice(-5);
      }

      function getDayOfYear() {
        const now = new Date();
        const start = new Date(now.getFullYear(), 0, 0);
        const diff =
          now -
          start +
          (start.getTimezoneOffset() - now.getTimezoneOffset()) * 60 * 1000;
        const oneDay = 1000 * 60 * 60 * 24;
        const dayOfYear = Math.floor(diff / oneDay);
        return dayOfYear;
      }

      async function updateGame(currentGameFirebaseId, gameBoard, whoseTurn) {
        const gameRef = doc(db, "games", currentGameFirebaseId);

        try {
          await updateDoc(gameRef, {
            gameBoard: gameBoard,
            whoseTurn: whoseTurn,
          });
          console.log("Game updated successfully");
        } catch (error) {
          console.error("Error updating game: ", error);
        }
      }

      async function deleteGame() {
        const gameRef = doc(db, "games", currentGameFirebaseId);

        try {
          await deleteDoc(gameRef);
          console.log(
            `Game with ID ${currentGameFirebaseId} has been deleted.`
          );
        } catch (error) {
          console.error("Error deleting game: ", error);
        }
      }

      async function listenForBroadcasts() {
        try {
          const broadcastCol = collection(db, "broadcast");
          const q = query(broadcastCol);
          const querySnapshot = await getDocs(q);
          const broadcastDoc = querySnapshot.docs[0];
          onSnapshot(broadcastDoc.ref, (docSnapshot) => {
            if (docSnapshot.exists()) {
              const broadcastData = docSnapshot.data();
              console.log("Real-time broadcast data: ", broadcastData);
              if (String(broadcastData.message).trim()) {
                alert(`Broadcast message: \n\n${broadcastData.message}`);
              }
            } else {
              console.log(
                "Could not set up real-time updates for broadcast doc."
              );
            }
          });
          // Call unsubscribe() when you no longer want to listen to updates
        } catch (error) {
          console.error(error);
        }
      }
    </script>
  </body>
</html>
