<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ScrabblEh?</title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/hchiam/css-boilerplate@7.0.0/style.css"
      integrity="sha384-4LyMgnYb2AiZtfGx9DmU1yIah53F9unFaCNv8tmbRTycOKKEfY1VleH71ezkUOT8"
      crossorigin="anonymous"
    />
    <style>
      :root {
        --cell-size: max(5vmin, 3rem);
        --grid-gap: 2px;
        --z-submitContainer: 3;
        --z-piece: 2;
        --z-cell-focused: 1;
      }
      body {
        padding-block-start: 1rem;
        padding-block-end: 2rem;
        padding-inline: 1rem;
        max-height: 100dvh;
        display: flex;
        flex-direction: column;
      }
      button {
        cursor: pointer;
      }
      #submitContainer {
        /* position: fixed;
        top: 0;
        left: 0;
        padding: 1rem;
        z-index: var(--z-submitContainer);
        display: flex;
        gap: 1rem; */
      }
      #scrabbleh {
        color: white;
      }
      #scrabbleh .eh {
        color: red;
      }
      #submit.haveCandidate,
      #cancel.haveCandidate,
      .cell.candidate {
        outline: var(--grid-gap) solid var(--accent-colour);
        @media (prefers-reduced-motion: no-preference) {
          animation: haveCandidate 1s infinite alternate;
        }
      }
      #gameId {
        width: 16ch;
        font-family: monospace;
      }
      .cell.candidate {
        outline-width: calc(var(--grid-gap) / 2);
      }
      @keyframes haveCandidate {
        to {
          background: maroon;
          color: white;
        }
      }
      #pieces {
        /*margin-block-start: 2.5rem;*/ /* so #submitContainer doesn't cover top */
        margin-block-start: 1rem;
        margin-block-end: 1rem;
      }
      .piece {
        width: var(--cell-size);
        height: var(--cell-size);
        margin: var(--grid-gap);
        display: inline-flex;
        justify-content: center;
        align-items: center;
        font-family: monospace;
        font-size: 1rem;
        font-weight: bold;
        z-index: var(--z-piece);
      }
      .piece.currentPiece {
        background: var(--accent-colour);
        color: black;
      }
      body[inert] .piece {
        background: rgb(50, 50, 50);
        color: whitesmoke;
      }
      #gameBoard {
        display: grid;
        grid-template-columns: repeat(15, var(--cell-size));
        grid-gap: var(--grid-gap);
        overflow: auto;
      }
      .cell {
        width: var(--cell-size);
        height: var(--cell-size);
        background: var(--background, #978967);
        color: var(--color, #fff);
        border-radius: 0;
        display: inline-flex;
        justify-content: center;
        align-items: center;
        text-align: center;
        vertical-align: middle;
        line-height: var(--cell-size);
        font-family: monospace;
        font-size: 1rem;
        font-weight: bold;
        outline: calc(var(--grid-gap) / 2) solid white;
      }
      .cell:focus,
      .cell:hover {
        background: lightgrey !important;
        color: black !important;
        box-shadow: 0 0 20px black;
        z-index: var(--z-cell-focused);
      }
      .cell.currentCell {
        background: var(--accent-colour) !important;
        color: black !important;
      }
      .cell:not(:empty) {
        background: rgb(50, 50, 50);
        color: white;
        pointer-events: none;
      }
    </style>
    <style id="dynamicStyle"></style>
    <script
      src="https://code.jquery.com/jquery-3.7.1.min.js"
      integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo="
      crossorigin="anonymous"
    ></script>
  </head>
  <body>
    <div id="submitContainer">
      <span id="scrabbleh">Scrabbl<span class="eh">Eh</span>?</span>
      <button id="submit">Submit</button>
      <button id="cancel">Cancel</button>
      <button id="goToGameId">Game ID:</button>
      <input id="gameId" placeholder="go to game ID" />
    </div>
    <div id="pieces"></div>
    <div id="gameBoard"></div>
    <script type="module">
      // firebase-app.js is the backbone for other firebase modules:
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.10.0/firebase-app.js";
      // TODO: Add SDKs for Firebase products that you want to use
      // https://firebase.google.com/docs/web/setup#available-libraries
      import {
        getAuth,
        signInAnonymously,
      } from "https://www.gstatic.com/firebasejs/10.10.0/firebase-auth.js";
      // like import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.10.0/firebase-analytics.js";
      import {
        getFirestore,
        collection,
        addDoc,
        query,
        where,
        getDocs,
        onSnapshot,
        doc,
        updateDoc,
        deleteDoc,
        serverTimestamp,
      } from "https://www.gstatic.com/firebasejs/10.10.0/firebase-firestore.js";

      // For Firebase JS SDK v7.20.0 and later, measurementId is optional
      const firebaseConfig = {
        apiKey: "AIzaSyBupDhYe5qrcd6WRqa1Pek1XDIq-xFzBDE",
        authDomain: "scrabbleh-57234.firebaseapp.com",
        projectId: "scrabbleh-57234",
        storageBucket: "scrabbleh-57234.appspot.com",
        messagingSenderId: "398177698307",
        appId: "1:398177698307:web:294e7448a71edab2040436",
        measurementId: "G-0297WR3Q99",
      };

      // Initialize Firebase
      const app = initializeApp(firebaseConfig);
      const db = getFirestore(app);
      const auth = getAuth();

      const red = new Set([0, 7, 14, 105, 119, 210, 217, 224]);
      const pink = new Set([
        16, 32, 48, 64, 28, 42, 56, 70, 196, 182, 168, 154, 208, 192, 176, 160,
      ]);
      const yellow = new Set([112]);
      const lightBlue = new Set([
        3, 11, 36, 38, 45, 52, 59, 92, 96, 98, 102, 108, 116, 122, 126, 128,
        132, 165, 172, 179, 186, 188, 213, 221,
      ]);
      const cornflowerBlue = new Set([
        20, 24, 76, 80, 84, 88, 136, 140, 144, 148, 200, 204,
      ]);
      let bagOfPieces = shuffle(
        "EEEEEEEEEEEEAAAAAAAAAIIIIIIIIIOOOOOOOONNNNNNRRRRRRTTTTTTLLLLSSSSUUUUDDDDGGGBBCCMMPPFFHHVVWWYYKJXQZ"
          /* TODO: + "??" */
          .split("")
      ).join("");
      localStorage.playerUid = "";
      let player1Pieces = "";
      let player2Pieces = "";
      let playerNumber = "";
      let whoseTurn = "";
      const piecePoints = {
        // "?": 0,
        E: 12,
        A: 1,
        I: 1,
        O: 1,
        N: 1,
        R: 1,
        T: 1,
        L: 1,
        S: 1,
        U: 1,
        D: 2,
        G: 2,
        B: 3,
        C: 3,
        M: 3,
        P: 3,
        F: 4,
        H: 4,
        V: 4,
        W: 4,
        Y: 4,
        K: 5,
        J: 8,
        X: 8,
        Q: 10,
        Z: 10,
      };
      const dynamicStyle = $("#dynamicStyle");
      const scrabbleh = $("#scrabbleh");
      const submit = $("#submit");
      const cancel = $("#cancel");
      const gameId = $("#gameId");
      const pieces = $("#pieces");
      const gameBoard = $("#gameBoard");

      let currentGameFirebaseId = "";
      let gameBoardString = " ".repeat(15 * 15);

      scrabbleh.show();
      submit.hide();
      cancel.hide();

      window.onload = async function initializeOnLoad() {
        await signIn().then(async (uid) => {
          localStorage.playerUid = uid;
          await setupRealtimeUpdates();
          await listenForBroadcasts();
          initSubmit();
          initCancel();
          initGoToGameId();
          initGameBoard();
        });
      };

      async function signIn() {
        try {
          const userCredential = await signInAnonymously(auth);
          const user = userCredential.user;
          // console.log("Signed in anonymously with UID:", user.uid);
          return user.uid;
        } catch (error) {
          console.error("Error signing in anonymously:", error);
          return null;
        }
      }

      function initSubmit() {
        submit.on("click", async () => {
          const candidateCells = [...gameBoard.find(".candidate")];

          // check for continuous chain:

          const chainRowOrColumn = candidateCells.filter(
            (el) => $(el).css("opacity") !== "0.5"
          );
          const chainLetters = chainRowOrColumn.map(
            (el) => $(el).text() || " "
          );
          const chainWord = chainLetters.join("").trim();
          if (chainWord.includes(" ")) {
            alert(
              `The letters must form connected chains. \nHit cancel to try again. \n\n"${chainWord}"`
            );
            return;
          }

          // check for valid intersecting words:

          let validIntersectingWords = true;
          const candidateIndices = candidateCells.map((x) => $(x).data("i"));
          const { min: minIndex, max: maxIndex } = candidateIndices.reduce(
            (acc, x) => {
              return { min: Math.min(acc.min, x), max: Math.max(acc.max, x) };
            },
            { min: Infinity, max: -Infinity }
          );
          const placedPiecesInARow = maxIndex - minIndex < 15;
          if (candidateCells.length === 1) {
            // check the intersecting row and the intersecting column
            if (hasRow(minIndex)) {
              validIntersectingWords &= await validateRow(minIndex);
              if (!validIntersectingWords) return;
            }
            if (hasColumn(minIndex)) {
              validIntersectingWords &= await validateColumn(minIndex);
              if (!validIntersectingWords) return;
            }
          } else if (placedPiecesInARow) {
            // check row just once and check all intersecting columns
            validIntersectingWords &= await validateRow(minIndex);
            if (!validIntersectingWords) return;
            for (let i = minIndex; i <= maxIndex; i++) {
              if (hasColumn(i)) {
                validIntersectingWords &= await validateColumn(i);
                if (!validIntersectingWords) return;
              }
            }
          } else {
            // check column just once and check all intersecting rows
            validIntersectingWords &= await validateColumn(minIndex);
            if (!validIntersectingWords) return;
            for (let i = minIndex; i <= maxIndex; i += 15) {
              if (hasRow(i)) {
                validIntersectingWords &= await validateRow(i);
                if (!validIntersectingWords) return;
              }
            }
          }

          if (!validIntersectingWords) return;

          gameBoardString = [...gameBoard.find(".cell")]
            .map((x) => $(x).text() || " ")
            .join("");

          const isPlayer1 = playerNumber === "player1";

          const piecesToReplace = Math.max(
            7 - pieces.find(".piece").length,
            candidateCells.length
          );
          const piecesToAdd = bagOfPieces.slice(0, piecesToReplace);
          bagOfPieces = bagOfPieces.slice(piecesToReplace);

          player1Pieces = isPlayer1
            ? pieces.find(".piece").text() + piecesToAdd
            : player1Pieces;

          player2Pieces = isPlayer1
            ? player2Pieces
            : pieces.find(".piece").text() + piecesToAdd;

          updateWhoseTurn(whoseTurn === "player1" ? "player2" : "player1");

          updatePieces(
            isPlayer1 ? player1Pieces.split("") : player2Pieces.split("")
          );

          // actually submit:
          await updateGame(
            currentGameFirebaseId,
            gameBoardString,
            player1Pieces,
            player2Pieces,
            whoseTurn
          );

          dynamicStyle.text("");

          gameBoard
            .find(".candidateFirstLetter, .candidate")
            .removeClass("candidateFirstLetter")
            .removeClass("candidate");

          submit.add(cancel).removeClass("haveCandidate");

          scrabbleh.show();
          submit.text("Submit").hide();
          cancel.text("Cancel").hide();
        });
      }

      function getRowIndex(i) {
        return Math.floor(i / 15); // think: which layer in the pancake stack
      }

      function getColumnIndex(i) {
        return i % 15; // think: how much overflow within a layer
      }

      function getIndexUp(i) {
        return i >= 15 ? i - 15 : -1; // -1 means invalid
      }

      function getIndexLeft(i) {
        return i % 15 !== 0 ? i - 1 : -1; // -1 means invalid
      }

      function getIndexRight(i) {
        return (i + 1) % 15 !== 0 ? i + 1 : -1; // -1 means invalid
      }

      function getIndexDown(i) {
        return i < 15 * 15 - 15 ? i + 15 : -1; // -1 means invalid
      }

      function hasRow(i) {
        if ($(`.cell[data-i="${i}"]`).text() === "") return false;
        return (
          $(`.cell[data-i="${getIndexLeft(i)}"]`).text() !== "" ||
          $(`.cell[data-i="${getIndexRight(i)}"]`).text() !== ""
        );
      }

      function hasColumn(i) {
        if ($(`.cell[data-i="${i}"]`).text() === "") return false;
        return (
          $(`.cell[data-i="${getIndexUp(i)}"]`).text() !== "" ||
          $(`.cell[data-i="${getIndexDown(i)}"]`).text() !== ""
        );
      }

      // check up/down and left/right
      async function validateColumn(i) {
        const lettersIndices = [i];
        let up = getIndexUp(i);
        let down = getIndexDown(i);
        while (up !== -1 && $(`.cell[data-i="${up}"]`).text()) {
          lettersIndices.unshift(up);
          up = getIndexUp(up);
        }
        while (down !== -1 && $(`.cell[data-i="${down}"]`).text()) {
          lettersIndices.push(down);
          down = getIndexDown(down);
        }
        const candidateColumnWord = lettersIndices
          .map((i) => $(`.cell[data-i="${i}"]`).text())
          .join("");
        const wordData = await getWordData(candidateColumnWord);
        if (wordData.isValid) {
          alert(
            `Word verified: "${candidateColumnWord}". \n\nFirst definition: ${wordData.firstDefinition}`
          );
        } else {
          alert(`A word could not be verified. \nHit cancel to try again.`);
        }
        return wordData.isValid;
      }

      async function validateRow(i) {
        const lettersIndices = [i];
        let left = getIndexLeft(i);
        let right = getIndexRight(i);
        while (left !== -1 && $(`.cell[data-i="${left}"]`).text()) {
          lettersIndices.unshift(left);
          left = getIndexLeft(left);
        }
        while (right !== -1 && $(`.cell[data-i="${right}"]`).text()) {
          lettersIndices.push(right);
          right = getIndexRight(right);
        }
        const candidateRowWord = lettersIndices
          .map((i) => $(`.cell[data-i="${i}"]`).text())
          .join("");
        const wordData = await getWordData(candidateRowWord);
        if (wordData.isValid) {
          alert(
            `Word verified: "${candidateRowWord}". \n\nFirst definition: ${wordData.firstDefinition}`
          );
        } else {
          alert(`A word could not be verified. \nHit cancel to try again.`);
        }
        return wordData.isValid;
      }

      function initCancel() {
        cancel.on("click", () => {
          const unusedPieces = pieces.text().split("");
          const candidateLetterCells = gameBoard.find(".candidate");
          const candidateLetters = candidateLetterCells.text().split("");
          candidateLetterCells.each((i, el) => $(el).text(""));
          updatePieces(unusedPieces.concat(candidateLetters));
          dynamicStyle.text("");
          gameBoard
            .find(".candidateFirstLetter, .candidate")
            .removeClass("candidateFirstLetter")
            .removeClass("candidate");

          submit.add(cancel).removeClass("haveCandidate");

          scrabbleh.show();
          submit.text("Submit").hide();
          cancel.text("Cancel").hide();
        });
      }

      function initGoToGameId() {
        $("#goToGameId").on("click", async () => {
          const gameID = gameId.val();
          if (!gameBoard.text()) {
            await deleteGame();
          }
          await joinGameByCustomId(gameID);

          scrabbleh.show();
          submit.text("Submit").hide();
          cancel.text("Cancel").hide();
        });
      }

      function updatePieces(lettersToAddArray) {
        let htmlString = "";
        lettersToAddArray.forEach((letter, count) => {
          htmlString += `<button class="piece">${String(letter)[0]}</button>`;
        });
        pieces.html(htmlString);
        pieces
          .find(".piece")
          .off("click")
          .on("click", (event) => {
            const currentPiece = $(event.target);
            if (currentPiece.hasClass("currentPiece")) {
              pieces.find(".currentPiece").removeClass("currentPiece");
            } else {
              pieces.find(".currentPiece").removeClass("currentPiece");
              currentPiece.addClass("currentPiece");
            }
            gameBoard.find(".currentCell").removeClass("currentCell");
          });
      }

      function initGameBoard() {
        let htmlString = "";
        for (let i = 0; i < gameBoardString.length; i++) {
          let style = "";
          if (red.has(i)) {
            style = `style="--background:red;--color:white;"`;
          } else if (pink.has(i)) {
            style = `style="--background:pink;--color:black;"`;
          } else if (yellow.has(i)) {
            style = `style="--background:yellow;--color:black;"`;
          } else if (lightBlue.has(i)) {
            style = `style="--background:lightBlue;--color:black;"`;
          } else if (cornflowerBlue.has(i)) {
            style = `style="--background:cornflowerBlue;--color:white;"`;
          }
          const cellValue = gameBoardString[i].trim() ? gameBoardString[i] : "";
          htmlString += `<button data-i="${i}" class="cell" ${
            style ? style : ""
          }>${cellValue}</button>`;
        }

        gameBoard.empty().append(htmlString);

        const cells = gameBoard.find(".cell");

        cells.off("click").on("click", (event) => {
          const currentCell = $(event.target);
          if (currentCell.hasClass("currentCell")) {
            gameBoard.find(".currentCell").removeClass("currentCell");
            return;
          }
          gameBoard.find(".currentCell").removeClass("currentCell");
          currentCell.addClass("currentCell");
          const currentPiece = $(".piece.currentPiece");
          if (!currentPiece.length) {
            return;
          }
          animateMove(currentPiece, currentCell);
          currentCell.text(currentPiece.text());

          currentCell.addClass("candidate");
          const addedOnePieceAlready = $("#submit").hasClass("haveCandidate");
          if (!addedOnePieceAlready) {
            currentCell.addClass("candidateFirstLetter");
          }

          currentPiece.removeClass("currentPiece");
          currentPiece.remove();
          currentCell.removeClass("currentCell");
          const i = currentCell.data("i");
          const row = getRowIndex(i);
          const column = getColumnIndex(i);
          const validColumn = `:nth-of-type(15n+${column + 1})`;
          const validRow = `:nth-of-type(n+${
            1 + row * 15
          }):not(:nth-of-type(n+${16 + row * 15}))`;
          if (addedOnePieceAlready) {
            // handle adding only a row XOR a column
            const firstCandidate = gameBoard.find(".candidateFirstLetter");
            const firstCandidateI = firstCandidate.data("i");
            const firstCandidateRow = getRowIndex(firstCandidateI);
            const firstCandidateColumn = getColumnIndex(firstCandidateI);
            const isInSameRow = row === firstCandidateRow;
            const isInSameColumn = column === firstCandidateColumn;
            if (isInSameRow) {
              dynamicStyle.text(
                `.cell:not(${validRow}) { pointer-events: none; opacity: 0.5; }`
              );
            } else if (isInSameColumn) {
              dynamicStyle.text(
                `.cell:not(${validColumn}) { pointer-events: none; opacity: 0.5; }`
              );
            }
          } else {
            // first piece placed lets you place next in a row or a column
            dynamicStyle.text(
              `.cell:not(${validColumn}):not(${validRow}) { pointer-events: none; opacity: 0.5; }`
            );
            scrabbleh.hide();
            submit.show().text("Submit?").addClass("haveCandidate");
            cancel.show().text("Cancel?").addClass("haveCandidate");
          }
        });
      }

      function animateMove(
        originElement,
        destinationElement,
        animationTime = 100
      ) {
        destinationElement.css("visibility", "hidden");
        const original = $(originElement);
        const originalMarginLeft = parseInt(original.css("marginLeft"));
        const originalMarginTop = parseInt(original.css("marginTop"));
        const originPosition = original.position();
        originPosition.left = originPosition.left + originalMarginLeft;
        originPosition.top = originPosition.top + originalMarginTop;
        const originalWidth = original.outerWidth();
        const originalHeight = original.outerHeight();
        const destinationPosition = $(destinationElement).position();
        const destinationWidth = $(destinationElement).outerWidth();
        const destinationHeight = $(destinationElement).outerHeight();
        const temp = original.clone();
        $("body").append(temp).prop("inert", true);
        temp.addClass("temp");
        temp.addClass("disable-hover").find("*").css({ pointerEvents: "none" });
        temp
          .css({
            position: "fixed",
            zIndex: 1,
            width: originalWidth,
            height: originalHeight,
          })
          .offset(originPosition)
          .animate(
            {
              left: destinationPosition.left,
              top: destinationPosition.top,
              width: destinationWidth,
              height: "auto", // destinationHeight,
            },
            animationTime
          );
        setTimeout(() => {
          temp.remove();
          $(destinationElement).css("visibility", "visible");
          $("body").prop("inert", false);
        }, animationTime * 10);
      }

      async function getWordData(word) {
        if (isProfanity(word)) {
          return { isValid: false, firstDefinition: "" };
        }
        const url = `https://api.dictionaryapi.dev/api/v2/entries/en/${word}`;
        return await fetch(url)
          .then((x) => x.json())
          .then((x) => {
            const errorTitle = "No Definitions Found";
            const foundEntry = !("title" in x && x.title.includes(errorTitle));
            const firstDefinition = foundEntry
              ? x[0].meanings[0].definitions[0].definition
              : "";
            return { isValid: foundEntry, firstDefinition: firstDefinition };
          });
      }

      async function setupRealtimeUpdates() {
        const gameID = gameId.val() || localStorage.gameId;
        if (gameID) {
          await joinGameByCustomId(gameID);
        } else {
          currentGameFirebaseId = await createGame();
          if (playerNumber === "player1") {
            updatePieces(player1Pieces.split(""));
          } else {
            updatePieces(player2Pieces.split(""));
          }
        }
      }

      async function joinGameByCustomId(customId) {
        try {
          const gamesCollection = collection(db, "games");
          const gameQuery = query(gamesCollection, where("id", "==", customId));
          const gameQuerySnapshot = await getDocs(gameQuery);
          if (!gameQuerySnapshot.empty) {
            // Assuming 'id' is unique, there should only be one doc
            if (gameQuerySnapshot.docs.length > 1) {
              console.warn("Multiple games found with the same custom ID.");
            }
            const gameDoc = gameQuerySnapshot.docs[0];
            const gameData = gameDoc.data();
            currentGameFirebaseId = gameDoc.id;
            gameBoardString = gameData.gameBoard;

            bagOfPieces = gameData.bagOfPieces;
            player1Pieces = gameData.player1Pieces;
            player2Pieces = gameData.player2Pieces;
            const isPlayer1 = localStorage.playerUid === gameData.player1Uid;
            playerNumber = isPlayer1 ? "player1" : "player2";
            updateWhoseTurn(gameData.whoseTurn); // depends on whether player1 already played
            updatePieces(
              isPlayer1 ? player1Pieces.split("") : player2Pieces.split("")
            );

            const canAddPlayer2 = gameData.player2Uid === "";
            if (canAddPlayer2) {
              updateGame(
                currentGameFirebaseId,
                gameBoard,
                player1Pieces,
                player2Pieces,
                whoseTurn,
                localStorage.playerUid
              );
            }

            gameId.val(customId);
            localStorage.gameId = customId;

            // Setting up real-time updates for the fetched game
            setupRealtimeUpdatesForGameDoc(gameDoc.ref);
          } else {
            console.log("No game found with the custom ID: ", customId);
            gameId.val("");
            localStorage.gameId = "";
            location.reload();
          }
        } catch (error) {
          const errorMessage = "Error fetching game by custom ID: " + error;
          console.error(errorMessage);
          alert(errorMessage);
        }
      }
      function setupRealtimeUpdatesForGameDoc(gameDocRef) {
        onSnapshot(gameDocRef, (docSnapshot) => {
          if (docSnapshot.exists()) {
            const gameData = docSnapshot.data();
            // console.log("Real-time game data: ", gameData);
            bagOfPieces = gameData.bagOfPieces;
            gameBoardString = gameData.gameBoard;
            player1Pieces = gameData.player1Pieces;
            player2Pieces = gameData.player2Pieces;
            updateWhoseTurn(gameData.whoseTurn);
            initGameBoard();
          } else {
            console.log("Could not set up real-time updates for a game doc.");
            gameId.val("");
            localStorage.gameId = "";
            location.reload();
          }
        });
      }

      async function createGame() {
        try {
          // Reference to the 'games' collection
          const gamesCollection = collection(db, "games");
          const randomId = getRandomId();
          gameId.val(randomId);
          localStorage.gameId = randomId;
          player1Pieces = bagOfPieces.slice(0, 7);
          player2Pieces = bagOfPieces.slice(7, 14);
          bagOfPieces = bagOfPieces.slice(14);
          playerNumber = "player1";
          updateWhoseTurn(playerNumber);
          // Add a new document with Firestore-generated unique ID
          const gameRef = await addDoc(gamesCollection, {
            id: randomId,
            timestamp: serverTimestamp(),
            player1Uid: localStorage.playerUid,
            player2Uid: "",
            player1Pieces: player1Pieces,
            player2Pieces: player2Pieces,
            whoseTurn: whoseTurn, // start the game with player 1 to let the game start faster
            gameBoard: " ".repeat(15 * 15),
            bagOfPieces: bagOfPieces,
          });
          console.log("Game created with ID: ", gameRef.id);
          return gameRef.id; // Returns the generated game ID
        } catch (error) {
          const errorMessage =
            "Can't create a new game right now. \n\nPlease wait a minute before trying again.";
          pieces.hide();
          gameBoard.hide();
          console.error(errorMessage);
          alert(errorMessage);
        }
      }

      function getRandomId() {
        // assumes people likely won't create a new game a year later at the exact same millisecond
        // this is just a toy project
        return (
          String(getDayOfYear()) + String(getMillisecondsSinceStartOfDay())
        );
      }

      function getDayOfYear() {
        const now = new Date();
        const start = new Date(now.getFullYear(), 0, 0);
        const diff =
          now -
          start +
          (start.getTimezoneOffset() - now.getTimezoneOffset()) * 60 * 1000;
        const oneDay = 1000 * 60 * 60 * 24;
        const dayOfYear = Math.floor(diff / oneDay);
        return dayOfYear;
      }

      function getMillisecondsSinceStartOfDay() {
        const dayStart = new Date();
        dayStart.setHours(0);
        dayStart.setMinutes(0);
        dayStart.setSeconds(0);
        dayStart.setMilliseconds(0);
        return new Date().getTime() - dayStart.getTime();
      }

      async function updateGame(
        currentGameFirebaseId,
        gameBoard,
        player1Pieces,
        player2Pieces,
        whoseTurn,
        player2Uid = ""
      ) {
        const gameRef = doc(db, "games", currentGameFirebaseId);

        let data = {
          id: String(gameId.val()),
          player1Pieces: player1Pieces,
          player2Pieces: player2Pieces,
          whoseTurn: whoseTurn,
          gameBoard: gameBoard,
          bagOfPieces: bagOfPieces,
        };
        if (player2Uid) {
          // adding player 2 to join the game:
          data = {
            id: String(gameId.val()),
            player2Uid: player2Uid,
          };
        }

        try {
          await updateDoc(gameRef, data);
          console.log("Game updated successfully");
        } catch (error) {
          console.error("Error updating game: ", error);
        }
      }

      async function deleteGame() {
        const gameRef = doc(db, "games", currentGameFirebaseId);

        try {
          await deleteDoc(gameRef);
          console.log(
            `Game with ID ${currentGameFirebaseId} has been deleted.`
          );
        } catch (error) {
          console.error("Error deleting game: ", error);
        }
      }

      async function listenForBroadcasts() {
        try {
          const broadcastCol = collection(db, "broadcast");
          const q = query(broadcastCol);
          const querySnapshot = await getDocs(q);
          const broadcastDoc = querySnapshot.docs[0];
          onSnapshot(broadcastDoc.ref, (docSnapshot) => {
            if (docSnapshot.exists()) {
              const broadcastData = docSnapshot.data();
              // console.log("Real-time broadcast data: ", broadcastData);
              if (String(broadcastData.message).trim()) {
                alert(`Broadcast message: \n\n${broadcastData.message}`);
              }
            } else {
              console.log(
                "Could not set up real-time updates for broadcast doc."
              );
            }
          });
          // Call unsubscribe() when you no longer want to listen to updates
        } catch (error) {
          console.error(error);
        }
      }

      const wordsToBlock = new Set(
        "YWNyb3RvbW9waGlsaWE=|YW5hbA==|YW5pbGluZ3Vz|YW51cw==|YXJzZWhvbGU=|YXNz|YXNzaG9sZQ==|YXNzbXVuY2g=|YXV0b2Vyb3RpYw==|YXV0b2Vyb3RpYw==|YmFiZWxhbmQ=|YmFieWJhdHRlcg==|YmFsbGdhZw==|YmFsbGdyYXZ5|YmFsbGtpY2tpbmc=|YmFsbGxpY2tpbmc=|YmFsbHNhY2s=|YmFsbHN1Y2tpbmc=|YmFuZ2Jyb3M=|YmFyZWJhY2s=|YmFyZWx5bGVnYWw=|YmFyZW5ha2Vk|YmFzdGFyZG8=|YmFzdGluYWRv|YmJ3|YmRzbQ==|YmVhdmVyY2xlYXZlcg==|YmVhdmVybGlwcw==|YmVzdGlhbGl0eQ==|YmljdXJpb3Vz|YmlnYmxhY2s=|YmlnYnJlYXN0cw==|Ymlna25vY2tlcnM=|YmlndGl0cw==|YmltYm9z|YmlyZGxvY2s=|Yml0Y2g=|YmxhY2tjb2Nr|YmxvbmRlYWN0aW9u|YmxvbmRlb25ibG9uZGVhY3Rpb24=|Ymxvd2o=|Ymxvd3lvdXJs|Ymx1ZXdhZmZsZQ==|Ymx1bXBraW4=|Ym9sbG9ja3M=|Ym9uZGFnZQ==|Ym9uZXI=|Ym9vYg==|Ym9vYnM=|Ym9vdHljYWxs|YnJvd25zaG93ZXJz|YnJ1bmV0dGVhY3Rpb24=|YnVra2FrZQ==|YnVsbGR5a2U=|YnVsbGV0dmliZQ==|YnVuZ2hvbGU=|YnVuZ2hvbGU=|YnVzdHk=|YnV0dA==|YnV0dGNoZWVrcw==|YnV0dGhvbGU=|Y2FtZWx0b2U=|Y2FtZ2lybA==|Y2Ftc2x1dA==|Y2Ftd2hvcmU=|Y2FycGV0bXVuY2hlcg==|Y2FycGV0bXVuY2hlcg==|Y2hvY29sYXRlcm9zZWJ1ZHM=|Y2lyY2xlamVyaw==|Y2xldmVsYW5kc3RlYW1lcg==|Y2xpdA==|Y2xpdG9yaXM=|Y2xvdmVyY2xhbXBz|Y2x1c3RlcmZ1Y2s=|Y29jaw==|Y29ja3M=|Y29wcm9sYWduaWE=|Y29wcm9waGlsaWE=|Y29ybmhvbGU=|Y3Vt|Y3VtbWluZw==|Y3VubmlsaW5ndXM=|Y3VudA==|ZGFya2ll|ZGF0ZXJhcGU=|ZGF0ZXJhcGU=|ZGVlcHRocm9hdA==|ZGVlcHRocm9hdA==|ZGljaw==|ZGlsZG8=|ZGlydHlwaWxsb3dz|ZGlydHlzYW5jaGV6|ZG9nc3R5bGU=|ZG9nZ2llc3R5bGU=|ZG9nZ2llc3R5bGU=|ZG9nZ3lzdHlsZQ==|ZG9nZ3lzdHlsZQ==|ZG9sY2V0dA==|ZG9taW5hdGlvbg==|ZG9taW5hdHJpeA==|ZG9tbWVz|ZG9ua2V5cHVuY2g=|ZG91YmxlZG9uZw==|ZG91YmxlcGVuZXRyYXRpb24=|ZHBhY3Rpb24=|ZWF0bXlhc3M=|ZWNjaGk=|ZWphY3VsYXRpb24=|ZXJvdGlj|ZXJvdGlzbQ==|ZXNjb3J0|ZXRoaWNhbHNsdXQ=|ZXVudWNo|ZmFnZ290|ZmVjYWw=|ZmVsY2g=|ZmVsbGF0aW8=|ZmVsdGNo|ZmVtYWxlc3F1aXJ0aW5n|ZmVtZG9t|ZmlnZ2luZw==|ZmluZ2VyaW5n|ZmlzdGluZw==|Zm9vdGZldGlzaA==|Zm9vdGpvYg==|ZnJvdHRpbmc=|ZnVjaw==|ZnVja2J1dHRvbnM=|ZnVkZ2VwYWNrZXI=|ZnVkZ2VwYWNrZXI=|ZnV0YW5hcmk=|Zy1zcG90|Z2FuZ2Jhbmc=|Z2F5c2V4|Z2VuaXRhbHM=|Z2lhbnRjb2Nr|Z2lybG9u|Z2lybG9udG9w|Z2lybHNnb25ld2lsZA==|Z29hdGN4|Z29hdHNl|Z29ra3Vu|Z29sZGVuc2hvd2Vy|Z29vZ2lybA==|Z29vZHBvb3A=|Z29yZWdhc20=|Z3JvcGU=|Z3JvdXBzZXg=|Z3Vybw==|aGFuZGpvYg==|aGFuZGpvYg==|aGFyZGNvcmU=|aGFyZGNvcmU=|aGVudGFp|aG9tb2Vyb3RpYw==|aG9ua2V5|aG9va2Vy|aG90Y2hpY2s=|aG93dG9raWxs|aG93dG9tdXJkZXI=|aHVnZWZhdA==|aHVtcGluZw==|aW5jZXN0|aW50ZXJjb3Vyc2U=|amFja29mZg==|amFpbGJhaXQ=|amFpbGJhaXQ=|amVya29mZg==|amlnYWJvbw==|amlnZ2Fib28=|amlnZ2VyYm9v|aml6eg==|anVnZ3M=|a2lrZQ==|a2luYmFrdQ==|a2lua3N0ZXI=|a2lua3k=|a25vYmJpbmc=|bGVhdGhlcnJlc3RyYWludA==|bGVhdGhlcnN0cmFpZ2h0amFja2V0|bGVtb25wYXJ0eQ==|bG9saXRh|bG92ZW1ha2luZw==|bWFrZW1lY29tZQ==|bWFsZXNxdWlydGluZw==|bWFzdHVyYmF0ZQ==|bWVuYWdlYXRyb2lz|bWlsZg==|bWlzc2lvbmFyeXBvc2l0aW9u|bW90aGVyZnVja2Vy|bW91bmRvZnZlbnVz|bXJoYW5kcw==|bXVmZmRpdmVy|bXVmZmRpdmluZw==|bmFtYmxh|bmF3YXNoaQ==|bmVncm8=|bmVvbmF6aQ==|bmlnbm9n|bmlnZ2E=|bmlnZ2Vy|bmltcGhvbWFuaWE=|bmlwcGxl|bmlwcGxlcw==|bnNmd2ltYWdlcw==|bnVkZQ==|bnVkaXR5|bnltcGhv|bnltcGhvbWFuaWE=|b2N0b3B1c3N5|b21vcmFzaGk=|b25lY3VwdHdvZ2lybHM=|b25lZ3V5b25lamFy|b3JnYXNt|b3JneQ==|cGFlZG9waGlsZQ==|cGFudGllcw==|cGFudHk=|cGVkb2JlYXI=|cGVkb3BoaWxl|cGVnZ2luZw==|cGVuaXM=|cGhvbmVzZXg=|cGllY2VvZnNoaXQ=|cGlzc3BpZw==|cGlzc2luZw==|cGlzc3BpZw==|cGxheWJveQ==|cGxlYXN1cmVjaGVzdA==|cG9sZXNtb2tlcg==|cG9ueXBsYXk=|cG9vZg==|cG9vcGNodXRl|cG9vcGNodXRl|cG9ybg==|cG9ybm8=|cG9ybm9ncmFwaHk=|cHJpbmNlYWxiZXJ0cGllcmNpbmc=|cHRoYw==|cHViZXM=|cHVzc3k=|cXVlYWY=|cmFnaGVhZA==|cmFnaW5nYm9uZXI=|cmFwZQ==|cmFwaW5n|cmFwaXN0|cmVjdHVt|cmV2ZXJzZWNvd2dpcmw=|cmltam9i|cmltbWluZw==|cm9zeXBhbG0=|cnVzdHl0cm9tYm9uZQ==|cyZt|c2FkaXNt|c2NhdA==|c2NobG9uZw==|c2Npc3NvcmluZw==|c2VtZW4=|c2V4|c2V4bw==|c2V4eQ==|c2hhdmVkYmVhdmVy|c2hhdmVkcHVzc3k=|c2hlbWFsZQ==|c2hpYmFyaQ==|c2hpdA==|c2hvdGE=|c2hyaW1waW5n|c2xhbnRleWU=|c2x1dA==|c211dA==|c25hdGNo|c25vd2JhbGxpbmc=|c29kb21pemU=|c29kb215|c3BpYw==|c3Bvb2dl|c3ByZWFkbGVncw==|c3RyYXBvbg==|c3RyYXBvbg==|c3RyYXBwYWRv|c3RyaXBjbHVi|c3R5bGVkb2dneQ==|c3Vjaw==|c3Vja3M=|c3VpY2lkZWdpcmxz|c3VsdHJ5d29tZW4=|c3dhc3Rpa2E=|c3dpbmdlcg==|dGFpbnRlZGxvdmU=|dGFzdGVteQ==|dGVhYmFnZ2luZw==|dGhyZWVzb21l|dGhyb2F0aW5n|dGllZHVw|dGlnaHR3aGl0ZQ==|dGl0|dGl0cw==|dGl0dGllcw==|dGl0dHk=|dG9uZ3VlaW5h|dG9wbGVzcw==|dG9zc2Vy|dG93ZWxoZWFk|dHJhbm55|dHJpYmFkaXNt|dHViZ2lybA==|dHViZ2lybA==|dHVzaHk=|dHdhdA==|dHdpbms=|dHdpbmtpZQ==|dHdvZ2lybHNvbmVjdXA=|dW5kcmVzc2luZw==|dXBza2lydA==|dXJldGhyYXBsYXk=|dXJvcGhpbGlh|dmFnaW5h|dmVudXNtb3VuZA==|dmlicmF0b3I=|dmlvbGV0d2FuZA==|dm9yYXJlcGhpbGlh|dm95ZXVy|dnVsdmE=|d2Fuaw==|d2V0ZHJlYW0=|d2V0YmFjaw==|d2hpdGVwb3dlcg==|d29tZW5yYXBwaW5n|d3JhcHBpbmdtZW4=|d3JpbmtsZWRzdGFyZmlzaA==|eHg=|eHh4|eWFvaQ==|eWVsbG93c2hvd2Vycw==|eWlmZnk=|em9vcGhpbGlh"
          .split("|")
          .map((x) => atob(x))
      );
      function isProfanity(word) {
        return wordsToBlock.has(word.toLowerCase());
      }

      function getRandomInteger(minInclusive, maxInclusive) {
        minInclusive = Math.ceil(minInclusive);
        maxInclusive = Math.floor(maxInclusive);
        const delta = maxInclusive - minInclusive;
        return Math.floor(Math.random() * (delta + 1)) + minInclusive;
      }

      function shuffle(array) {
        // use Fisher-Yates shuffling algorithm:
        function swap(arr, i, j) {
          const temp = arr[i];
          arr[i] = arr[j];
          arr[j] = temp;
        }
        for (let i = 0; i < array.length; i++) {
          // random index from the elements still remaining in the "hat":
          const j = Math.floor(Math.random() * (array.length - i)) + i;
          swap(array, i, j);
        }
        return array;
      }

      function updateWhoseTurn(player) {
        whoseTurn = player;
        // whoseTurn should disable buttons while detecting whether you're player 1 or 2:
        submit
          .add(cancel)
          .add(pieces)
          .add(gameBoard)
          .prop("inert", whoseTurn !== playerNumber);
      }
    </script>
  </body>
</html>
