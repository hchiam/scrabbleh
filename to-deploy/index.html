<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ScrabblEh?</title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/hchiam/css-boilerplate@7.0.0/style.css"
      integrity="sha384-4LyMgnYb2AiZtfGx9DmU1yIah53F9unFaCNv8tmbRTycOKKEfY1VleH71ezkUOT8"
      crossorigin="anonymous"
    />
    <style>
      :root {
        --cell-size: max(5vmin, 3rem);
        --grid-gap: 2px;
        --z-submitContainer: 3;
        --z-piece: 2;
        --z-cell-focused: 1;
      }
      body {
        padding-block-start: 1rem;
        padding-block-end: 2rem;
        padding-inline: 1rem;
        max-height: 100dvh;
        display: flex;
        flex-direction: column;
      }
      button {
        cursor: pointer;
      }
      #submitContainer {
        /* position: fixed;
        top: 0;
        left: 0;
        padding: 1rem;
        z-index: var(--z-submitContainer);
        display: flex;
        gap: 1rem; */
      }
      #gameId {
        width: 16ch;
        font-family: monospace;
      }
      label[for="player1ScoreInput"],
      label[for="player2ScoreInput"] {
        font-size: 0.6rem;
        position: absolute;
        background: transparent;
        color: var(--accent-colour);
      }
      #player1ScoreInput,
      #player2ScoreInput {
        width: 4.5ch;
        padding-inline: 0;
        text-align: center;
      }
      #player1ScoreInput.you,
      #player2ScoreInput.you {
        background: oklch(100% 0 0 / 16%);
        color: red;
      }
      #scrabbleh {
        color: white;
      }
      #scrabbleh .eh {
        color: red;
      }
      #submit.haveCandidate,
      #cancel.haveCandidate,
      .cell.candidate {
        outline: var(--grid-gap) solid var(--accent-colour);
        @media (prefers-reduced-motion: no-preference) {
          animation: haveCandidate 1s infinite alternate;
        }
      }
      .cell.candidate {
        outline-width: calc(var(--grid-gap) / 2);
      }
      @keyframes haveCandidate {
        to {
          background: maroon;
          color: white;
        }
      }
      #pieces {
        /*margin-block-start: 2.5rem;*/ /* so #submitContainer doesn't cover top */
        margin-block-start: 1rem;
        margin-block-end: 1rem;
      }
      body.showingHiddenGame #pieces {
        display: none;
      }
      .piece {
        width: var(--cell-size);
        height: var(--cell-size);
        margin: var(--grid-gap);
        display: inline-flex;
        justify-content: center;
        align-items: center;
        font-family: monospace;
        font-size: 1rem;
        font-weight: bold;
        z-index: var(--z-piece);
        position: relative; /* so :after can be position: absolute; */
      }
      .piece.currentPiece {
        background: var(--accent-colour);
        color: black;
      }
      .piece:not(.currentPiece),
      .piece:not(.currentPiece):focus,
      .piece:not(.currentPiece):hover {
        background: rgb(50, 50, 50);
        color: whitesmoke;
      }
      body[inert] .piece {
        background: rgb(50, 50, 50);
        color: whitesmoke;
      }
      #pieces[inert] .piece {
        color: gray;
      }
      body.showingHiddenGame .piece {
        pointer-events: none;
      }
      #spectator {
        display: none;
        color: yellow;
        font-weight: bold;
        margin-block: 1rem;
      }
      #gameBoardWrapper {
        overflow: auto;
      }
      body.showingHiddenGame #gameBoardWrapper {
        overflow: revert;
        perspective: 1000px;
        transform-style: preserve-3d;
        width: calc(var(--cell-size) * 15 / 2);
        margin-block: 0;
        margin-inline: auto;
      }
      body.showingHiddenGame #gameBoardTransformContainer {
        transform: scale(0.5) translate(-50%, -120%) rotateX(50deg);
        transform-origin: bottom;
        transform-style: inherit;
        position: absolute;
        pointer-events: none;
        margin-inline: -1rem;
      }
      #gameBoard {
        display: grid;
        grid-template-columns: repeat(15, var(--cell-size));
        grid-gap: var(--grid-gap);
      }
      body.showingHiddenGame #gameBoard {
        grid-gap: 0;
      }
      .cell {
        width: var(--cell-size);
        height: var(--cell-size);
        background: var(--background, #978967);
        color: var(--color, #fff);
        border-radius: 0;
        display: inline-flex;
        justify-content: center;
        align-items: center;
        text-align: center;
        vertical-align: middle;
        font-family: monospace;
        font-size: 1rem;
        font-weight: bold;
        outline: calc(var(--grid-gap) / 2) solid white;
        position: relative; /* so :after can be position: absolute; */
      }
      .cell:focus,
      .cell:hover {
        background: lightgrey !important;
        color: black !important;
        box-shadow: 0 0 20px black;
        z-index: var(--z-cell-focused);
      }
      .cell.currentCell {
        color: black !important;
      }
      .cell:not(:empty) {
        background: rgb(50, 50, 50);
        color: white;
        pointer-events: none;
      }
      body.showingHiddenGame .cell {
        outline-color: transparent;
        pointer-events: none;
        opacity: 0.7;
      }
      body.showingHiddenGame .cell:not(:empty) {
        opacity: 1;
        background: yellow;
        color: black;
        border-radius: 50%;
        transform: scale(0.5);
        font-size: 3rem;
        @media (prefers-reduced-motion: no-preference) {
          animation: flashing-points 1s infinite alternate;
        }
      }
      @keyframes flashing-points {
        to {
          background: peachpuff;
        }
      }

      #hiddenGameControls {
        pointer-events: none;
        display: flex;
        position: fixed;
        bottom: -10rem;
        width: calc(100% - 2rem);
      }
      body.showingHiddenGame #hiddenGameControls {
        pointer-events: revert;
        gap: 1rem;
        bottom: 2rem;
        transition-delay: 1s;
      }
      body.showingHiddenGame #hiddenGameControls button:nth-of-type(2) {
        margin-right: auto;
      }
      body.showingHiddenGame #hiddenGameControls button kbd {
        padding: 0.25rem;
      }
      #player1Character,
      #player2Character {
        opacity: 0;
        pointer-events: none;
        position: absolute;
        top: 0;
        left: 0;
        transition: opacity 1s, transform 0.1s;
        display: flex;
        justify-content: center;
        align-items: center;
        background: red;
        color: white;
        font-weight: bold;
      }
      #player1Character.you,
      #player2Character.you {
        background: white;
        color: red;
      }
      #player1Character.you:after,
      #player2Character.you:after {
        content: "⇩";
        position: absolute;
        top: -5.5rem;
        left: 0.75rem;
        font-size: 5rem;
        color: yellow;
        filter: drop-shadow(0 0 5px red);
        transform: rotateZ(20deg);
      }
      #player1Character.consumer,
      #player2Character.consumer {
        background: yellow !important;
        color: black !important;
      }
      #player1Character:not(.consumer),
      #player2Character:not(.consumer) {
        background: red !important;
        color: white !important;
        transition: opacity 1s, transform 0.05s;
      }
      body.showingHiddenGame #player1Character,
      body.showingHiddenGame #player2Character {
        opacity: 1;
        height: var(--cell-size);
        width: var(--cell-size);
        transform: translateZ(10px);
        box-shadow: 5px 5px 10px rgba(0, 0, 0, 0.3);
        border-radius: 50%;
        border: 3px solid var(--accent-colour);
      }
      .piece::after,
      .cell::after {
        position: absolute;
        bottom: 0%;
        right: 0.25em;
        font-size: small;
      }
      .piece:where(.E, .A, .I, .O, .N, .R, .T, .L, .S, .U)::after,
      .cell:where(.E, .A, .I, .O, .N, .R, .T, .L, .S, .U)::after {
        content: "1";
      }
      .piece:where(.D, .G)::after,
      .cell:where(.D, .G)::after {
        content: "2";
      }
      .piece:where(.B, .C, .M, .P)::after,
      .cell:where(.B, .C, .M, .P)::after {
        content: "3";
      }
      .piece:where(.F, .H, .V, .W, .Y)::after,
      .cell:where(.F, .H, .V, .W, .Y)::after {
        content: "4";
      }
      .piece:where(.K)::after,
      .cell:where(.K)::after {
        content: "5";
      }
      .piece:where(.J, .X)::after,
      .cell:where(.J, .X)::after {
        content: "8";
      }
      .piece:where(.Q, .Z)::after,
      .cell:where(.Q, .Z)::after {
        content: "10";
      }
      .cell::before {
        position: absolute;
        transform: translate(-50%, -50%);
        left: 50%;
        top: 50%;
      }
      .cell.x3W::before {
        content: "3W";
      }
      .cell.x2W::before {
        content: "2W";
      }
      .cell.x3L::before {
        content: "3L";
      }
      .cell.x2L::before {
        content: "2L";
      }
      .cell.x3W:not(:empty)::before,
      .cell.x2W:not(:empty)::before,
      .cell.x3L:not(:empty)::before,
      .cell.x2L:not(:empty)::before {
        position: absolute;
        top: 0.5em;
        left: 0.6em;
        font-size: small;
      }
      body.showingHiddenGame .cell.wall {
        background: red;
        border-radius: 0;
        transform: none;
        @media (prefers-reduced-motion: no-preference) {
          animation: flashing-walls 1s infinite alternate;
        }
      }
      @keyframes flashing-walls {
        to {
          background: hotpink;
        }
      }
    </style>
    <style id="dynamicStyle"></style>
    <script
      src="https://code.jquery.com/jquery-3.7.1.min.js"
      integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo="
      crossorigin="anonymous"
    ></script>
  </head>
  <body>
    <div id="submitContainer">
      <button id="goToGameId">Game ID:</button>
      <input id="gameId" placeholder="go to game ID" />
      <label for="player1ScoreInput">&nbsp;P1:</label
      ><input id="player1ScoreInput" value="0" disabled />
      <label for="player2ScoreInput">&nbsp;P2:</label
      ><input id="player2ScoreInput" value="0" disabled />
      <span id="scrabbleh">Scrabbl<span class="eh">Eh</span>?</span>
      <button id="submit">Submit</button>
      <button id="cancel">Cancel</button>
      <p id="spectator">(You are spectating.)</p>
    </div>
    <div id="pieces"></div>
    <div id="gameBoardWrapper">
      <div id="gameBoardTransformContainer">
        <div id="gameBoard"></div>
        <div id="player1Character">P1</div>
        <div id="player2Character">P2</div>
      </div>
    </div>
    <div id="hiddenGameControls">
      <button id="a">◀ <kbd>a</kbd></button>
      <button id="d">▶ <kbd>d</kbd></button>
      <button id="w">▲ <kbd>w</kbd></button>
      <button id="s">▼ <kbd>s</kbd></button>
    </div>
    <script type="module">
      // firebase-app.js is the backbone for other firebase modules:
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.10.0/firebase-app.js";
      // TODO: Add SDKs for Firebase products that you want to use
      // https://firebase.google.com/docs/web/setup#available-libraries
      import {
        getAuth,
        signInAnonymously,
      } from "https://www.gstatic.com/firebasejs/10.10.0/firebase-auth.js";
      // like import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.10.0/firebase-analytics.js";
      import {
        getFirestore,
        collection,
        addDoc,
        query,
        where,
        getDocs,
        onSnapshot,
        doc,
        updateDoc,
        deleteDoc,
        serverTimestamp,
      } from "https://www.gstatic.com/firebasejs/10.10.0/firebase-firestore.js";

      // For Firebase JS SDK v7.20.0 and later, measurementId is optional
      const firebaseConfig = {
        apiKey: "AIzaSyBupDhYe5qrcd6WRqa1Pek1XDIq-xFzBDE",
        authDomain: "scrabbleh-57234.firebaseapp.com",
        projectId: "scrabbleh-57234",
        storageBucket: "scrabbleh-57234.appspot.com",
        messagingSenderId: "398177698307",
        appId: "1:398177698307:web:294e7448a71edab2040436",
        measurementId: "G-0297WR3Q99",
      };

      // Initialize Firebase
      const app = initializeApp(firebaseConfig);
      const db = getFirestore(app);
      const auth = getAuth();

      const red = new Set([0, 7, 14, 105, 119, 210, 217, 224]);
      const pink = new Set([
        16, 32, 48, 64, 28, 42, 56, 70, 196, 182, 168, 154, 208, 192, 176, 160,
      ]);
      const yellow = new Set([112]);
      const lightBlue = new Set([
        3, 11, 36, 38, 45, 52, 59, 92, 96, 98, 102, 108, 116, 122, 126, 128,
        132, 165, 172, 179, 186, 188, 213, 221,
      ]);
      const cornflowerBlue = new Set([
        20, 24, 76, 80, 84, 88, 136, 140, 144, 148, 200, 204,
      ]);
      let bagOfPieces = shuffle(
        "EEEEEEEEEEEEAAAAAAAAAIIIIIIIIIOOOOOOOONNNNNNRRRRRRTTTTTTLLLLSSSSUUUUDDDDGGGBBCCMMPPFFHHVVWWYYKJXQZ"
          /* TODO: + "??" */
          .split("")
      ).join("");
      localStorage.playerUid = "";
      const player1ScoreLabel = $('label[for="player1ScoreInput"]');
      const player2ScoreLabel = $('label[for="player2ScoreInput"]');
      const player1ScoreInput = $("#player1ScoreInput");
      const player2ScoreInput = $("#player2ScoreInput");
      let player1Score = 0;
      let player2Score = 0;
      let player1Pieces = "";
      let player2Pieces = "";
      let playerNumber = "";
      let whoseTurn = "";
      let isP1OrP2 = false;
      const piecePoints = {
        // "?": 0,
        E: 1,
        A: 1,
        I: 1,
        O: 1,
        N: 1,
        R: 1,
        T: 1,
        L: 1,
        S: 1,
        U: 1,
        D: 2,
        G: 2,
        B: 3,
        C: 3,
        M: 3,
        P: 3,
        F: 4,
        H: 4,
        V: 4,
        W: 4,
        Y: 4,
        K: 5,
        J: 8,
        X: 8,
        Q: 10,
        Z: 10,
      };
      const dynamicStyle = $("#dynamicStyle");
      const scrabbleh = $("#scrabbleh");
      const submit = $("#submit");
      const cancel = $("#cancel");
      const spectator = $("#spectator");
      const gameId = $("#gameId");
      const pieces = $("#pieces");
      const gameBoard = $("#gameBoard");
      const hiddenGameControls = $("#hiddenGameControls");
      const player1Character = $("#player1Character");
      const player2Character = $("#player2Character");

      let currentGameFirebaseId = "";
      let gameBoardString = " ".repeat(15 * 15);
      let showingHiddenGame = false;
      let xy1 = "";
      let xy2 = "";
      let consumer = "";
      const wall = "*";

      scrabbleh.show();
      submit.hide();
      cancel.hide();

      window.onload = async function initializeOnLoad() {
        await signIn().then(async (uid) => {
          localStorage.playerUid = uid;
          await setupRealtimeUpdates();
          await listenForBroadcasts();
          initSubmit();
          initCancel();
          initGameId();
          initGoToGameId();
          initGameBoard();
          initHiddenGameControls();
        });
      };

      async function signIn() {
        try {
          const userCredential = await signInAnonymously(auth);
          const user = userCredential.user;
          // console.log("Signed in anonymously with UID:", user.uid);
          return user.uid;
        } catch (error) {
          console.error("Error signing in anonymously:", error);
          return null;
        }
      }

      function initSubmit() {
        submit.on("click", async () => {
          const candidateCells = [...gameBoard.find(".candidate")];

          // check for continuous chain:

          const chainRowOrColumn = candidateCells.filter(
            (el) => $(el).css("opacity") !== "0.5"
          );
          const chainLetters = chainRowOrColumn.map(
            (el) => $(el).text() || " "
          );
          const chainWord = chainLetters.join("").trim();
          if (chainWord.includes(" ")) {
            alert(
              `The letters must form connected chains. \nHit cancel to try again. \n\n"${chainWord}"`
            );
            return;
          }

          // check for valid intersecting words:

          let validIntersectingWords = true;
          const candidateIndices = candidateCells.map((x) => $(x).data("i"));
          const { min: minIndex, max: maxIndex } = candidateIndices.reduce(
            (acc, x) => {
              return { min: Math.min(acc.min, x), max: Math.max(acc.max, x) };
            },
            { min: Infinity, max: -Infinity }
          );
          const placedPiecesInARow = maxIndex - minIndex < 15;
          if (candidateCells.length === 1) {
            // check the intersecting row and the intersecting column
            if (hasRow(minIndex)) {
              validIntersectingWords &= await validateRow(minIndex);
              if (!validIntersectingWords) return;
            }
            if (hasColumn(minIndex)) {
              validIntersectingWords &= await validateColumn(minIndex);
              if (!validIntersectingWords) return;
            }
          } else if (placedPiecesInARow) {
            // check row just once and check all intersecting columns
            validIntersectingWords &= await validateRow(minIndex);
            if (!validIntersectingWords) return;
            for (let i = minIndex; i <= maxIndex; i++) {
              if (hasColumn(i)) {
                validIntersectingWords &= await validateColumn(i);
                if (!validIntersectingWords) return;
              }
            }
          } else {
            // check column just once and check all intersecting rows
            validIntersectingWords &= await validateColumn(minIndex);
            if (!validIntersectingWords) return;
            for (let i = minIndex; i <= maxIndex; i += 15) {
              if (hasRow(i)) {
                validIntersectingWords &= await validateRow(i);
                if (!validIntersectingWords) return;
              }
            }
          }

          if (!validIntersectingWords) return;

          // can now proceed with updates:

          gameBoardString = [...gameBoard.find(".cell")]
            .map((x) => $(x).text() || " ")
            .join("");

          const addedPoints = getPointsToAdd();

          const isPlayer1 = playerNumber === "player1";

          player1Score += isPlayer1 ? addedPoints : 0;
          player2Score += isPlayer1 ? 0 : addedPoints;
          player1ScoreInput.val(player1Score);
          player2ScoreInput.val(player2Score);

          const piecesToReplace = Math.max(
            7 - pieces.find(".piece").length,
            candidateCells.length
          );
          const piecesToAdd = bagOfPieces.slice(0, piecesToReplace);
          bagOfPieces = bagOfPieces.slice(piecesToReplace);

          player1Pieces = isPlayer1
            ? pieces.find(".piece").text() + piecesToAdd
            : player1Pieces;

          player2Pieces = isPlayer1
            ? player2Pieces
            : pieces.find(".piece").text() + piecesToAdd;

          updateWhoseTurn(whoseTurn === "player1" ? "player2" : "player1");

          // check before submit:
          const lettersPlacedDown = gameBoard.find(".candidate").text();
          const placedDownEOrH =
            lettersPlacedDown.includes("E") || lettersPlacedDown.includes("H");

          // actually submit:
          await updateGame(
            currentGameFirebaseId,
            gameBoardString,
            player1Score,
            player2Score,
            player1Pieces,
            player2Pieces,
            whoseTurn,
            isPlayer1 ? localStorage.playerUid : "",
            isPlayer1 ? "" : localStorage.playerUid
          );

          candidateCells.forEach((el) => {
            $(el)
              .removeClass(
                "A B C D E F G H I J K L M N O P W R S T U V W X Y Z"
              )
              .removeClass("x3W x2W x3L x2L") // can't reuse multipliers
              .removeAttr("style");
          });

          updatePieces(
            isPlayer1 ? player1Pieces.split("") : player2Pieces.split("")
          );

          dynamicStyle.text("");

          gameBoard
            .find(".candidateFirstLetter, .candidate")
            .removeClass("candidateFirstLetter")
            .removeClass("candidate");

          submit.add(cancel).removeClass("haveCandidate");

          scrabbleh.show();
          submit.text("Submit").hide();
          cancel.text("Cancel").hide();

          if (placedDownEOrH) {
            toggleHiddenGameControls(true);
          }
        });
      }

      function getRowIndex(i) {
        return Math.floor(i / 15); // think: which layer in the pancake stack
      }

      function getColumnIndex(i) {
        return i % 15; // think: how much overflow within a layer
      }

      function getIndexUp(i) {
        return i >= 15 ? i - 15 : -1; // -1 means invalid
      }

      function getIndexLeft(i) {
        return i % 15 !== 0 ? i - 1 : -1; // -1 means invalid
      }

      function getIndexRight(i) {
        return (i + 1) % 15 !== 0 ? i + 1 : -1; // -1 means invalid
      }

      function getIndexDown(i) {
        return i < 15 * 15 - 15 ? i + 15 : -1; // -1 means invalid
      }

      function hasRow(i) {
        if ($(`.cell[data-i="${i}"]`).text() === "") return false;
        return (
          $(`.cell[data-i="${getIndexLeft(i)}"]`).text() !== "" ||
          $(`.cell[data-i="${getIndexRight(i)}"]`).text() !== ""
        );
      }

      function hasColumn(i) {
        if ($(`.cell[data-i="${i}"]`).text() === "") return false;
        return (
          $(`.cell[data-i="${getIndexUp(i)}"]`).text() !== "" ||
          $(`.cell[data-i="${getIndexDown(i)}"]`).text() !== ""
        );
      }

      // check up/down and left/right
      async function validateColumn(i) {
        const lettersIndices = [i];
        let up = getIndexUp(i);
        let down = getIndexDown(i);
        while (up !== -1 && $(`.cell[data-i="${up}"]`).text()) {
          lettersIndices.unshift(up);
          up = getIndexUp(up);
        }
        while (down !== -1 && $(`.cell[data-i="${down}"]`).text()) {
          lettersIndices.push(down);
          down = getIndexDown(down);
        }
        const candidateColumnWord = lettersIndices
          .map((i) => $(`.cell[data-i="${i}"]`).text())
          .join("");
        const wordData = await getWordData(candidateColumnWord);
        if (wordData.isValid) {
          alert(
            `Word verified: "${candidateColumnWord}". \n\nFirst definition: ${wordData.firstDefinition}`
          );
        } else {
          alert(`A word could not be verified. \nHit cancel to try again.`);
        }
        return wordData.isValid;
      }

      async function validateRow(i) {
        const lettersIndices = [i];
        let left = getIndexLeft(i);
        let right = getIndexRight(i);
        while (left !== -1 && $(`.cell[data-i="${left}"]`).text()) {
          lettersIndices.unshift(left);
          left = getIndexLeft(left);
        }
        while (right !== -1 && $(`.cell[data-i="${right}"]`).text()) {
          lettersIndices.push(right);
          right = getIndexRight(right);
        }
        const candidateRowWord = lettersIndices
          .map((i) => $(`.cell[data-i="${i}"]`).text())
          .join("");
        const wordData = await getWordData(candidateRowWord);
        if (wordData.isValid) {
          alert(
            `Word verified: "${candidateRowWord}". \n\nFirst definition: ${wordData.firstDefinition}`
          );
        } else {
          alert(`A word could not be verified. \nHit cancel to try again.`);
        }
        return wordData.isValid;
      }

      function initCancel() {
        cancel.on("click", () => {
          const unusedPieces = pieces.text().split("");
          const candidateLetterCells = gameBoard.find(".candidate");
          const candidateLetters = candidateLetterCells.text().split("");
          candidateLetterCells.each((i, el) => {
            $(el).text("");
          });
          candidateLetterCells.removeClass(
            "A B C D E F G H I J K L M N O P W R S T U V W X Y Z"
          ); // cancelling shouldn't remove x3W x2W x3L x2L multipliers (need a successful submit)
          updatePieces(unusedPieces.concat(candidateLetters));
          dynamicStyle.text("");
          gameBoard
            .find(".candidateFirstLetter, .candidate")
            .removeClass("candidateFirstLetter")
            .removeClass("candidate");

          submit.add(cancel).removeClass("haveCandidate");

          scrabbleh.show();
          submit.text("Submit").hide();
          cancel.text("Cancel").hide();
        });
      }

      function initGameId() {
        gameId.on("keyup change", () => {
          formatGameId();
        });
      }

      function formatGameId() {
        const val = String(gameId.val());
        const processedVal = splitIntoGroupsOf4FromLeft(val);
        gameId.val(processedVal);
      }

      function splitIntoGroupsOf4FromLeft(val) {
        return val
          .replace(/\D/g, "")
          .split(/(\d{4})/g)
          .filter((x) => x)
          .join(" ");
      }

      function initGoToGameId() {
        $("#goToGameId").on("click", async () => {
          const gameID = String(gameId.val()).replace(/\D/g, "");
          if (!gameBoard.text()) {
            await deleteGame();
          }
          await joinGameByCustomId(gameID);

          scrabbleh.show();
          submit.text("Submit").hide();
          cancel.text("Cancel").hide();
        });
      }

      function updatePieces(lettersToAddArray) {
        let htmlString = "";
        lettersToAddArray.forEach((letter, count) => {
          const whatLetter = String(letter)[0];
          htmlString += `<button class="piece ${whatLetter}">${whatLetter}</button>`;
        });
        pieces.html(htmlString);
        pieces
          .find(".piece")
          .off("click")
          .on("click", (event) => {
            const currentPiece = $(event.target);
            if (currentPiece.hasClass("currentPiece")) {
              pieces.find(".currentPiece").removeClass("currentPiece");
            } else {
              pieces.find(".currentPiece").removeClass("currentPiece");
              currentPiece.addClass("currentPiece");
            }
            gameBoard.find(".currentCell").removeClass("currentCell");
          });
      }

      function initGameBoard() {
        let htmlString = "";
        for (let i = 0; i < gameBoardString.length; i++) {
          let style = "";
          let multiplier = "";
          if (red.has(i) && gameBoardString[i] === " ") {
            style = `style="--background:red;--color:white;"`;
            multiplier = "x3W";
          } else if (pink.has(i) && gameBoardString[i] === " ") {
            style = `style="--background:pink;--color:black;"`;
            multiplier = "x2W";
          } else if (yellow.has(i) && gameBoardString[i] === " ") {
            style = `style="--background:yellow;--color:black;"`;
            multiplier = "x2W";
          } else if (lightBlue.has(i) && gameBoardString[i] === " ") {
            style = `style="--background:lightBlue;--color:black;"`;
            multiplier = "x2L";
          } else if (cornflowerBlue.has(i) && gameBoardString[i] === " ") {
            style = `style="--background:cornflowerBlue;--color:white;"`;
            multiplier = "x3L";
          }
          const cellValue = gameBoardString[i].trim() ? gameBoardString[i] : "";
          const wallClass = cellValue === wall ? "wall" : "";
          htmlString += `<button data-i="${i}" class="cell ${multiplier} ${wallClass}" ${style}>${cellValue}</button>`;
        }

        gameBoard.empty().append(htmlString);

        const cells = gameBoard.find(".cell");

        cells.off("click").on("click", (event) => {
          const currentCell = $(event.target);
          if (currentCell.hasClass("currentCell")) {
            gameBoard.find(".currentCell").removeClass("currentCell");
            return;
          }
          gameBoard.find(".currentCell").removeClass("currentCell");
          currentCell.addClass("currentCell");
          const currentPiece = $(".piece.currentPiece");
          if (!currentPiece.length) {
            return;
          }
          animateMove(currentPiece, currentCell);
          currentCell.text(currentPiece.text());
          currentCell.addClass(currentPiece[0].classList[1]);

          currentCell.addClass("candidate");
          const addedOnePieceAlready = $("#submit").hasClass("haveCandidate");
          if (!addedOnePieceAlready) {
            currentCell.addClass("candidateFirstLetter");
          }

          currentPiece.removeClass("currentPiece");
          currentPiece.remove();
          currentCell.removeClass("currentCell");
          const i = currentCell.data("i");
          const row = getRowIndex(i);
          const column = getColumnIndex(i);
          const validColumn = `:nth-of-type(15n+${column + 1})`;
          const validRow = `:nth-of-type(n+${
            1 + row * 15
          }):not(:nth-of-type(n+${16 + row * 15}))`;
          if (addedOnePieceAlready) {
            // handle adding only a row XOR a column
            const firstCandidate = gameBoard.find(".candidateFirstLetter");
            const firstCandidateI = firstCandidate.data("i");
            const firstCandidateRow = getRowIndex(firstCandidateI);
            const firstCandidateColumn = getColumnIndex(firstCandidateI);
            const isInSameRow = row === firstCandidateRow;
            const isInSameColumn = column === firstCandidateColumn;
            if (isInSameRow) {
              dynamicStyle.text(
                `.cell:not(${validRow}) { pointer-events: none; opacity: 0.5; }`
              );
            } else if (isInSameColumn) {
              dynamicStyle.text(
                `.cell:not(${validColumn}) { pointer-events: none; opacity: 0.5; }`
              );
            }
          } else {
            // first piece placed lets you place next in a row or a column
            dynamicStyle.text(
              `.cell:not(${validColumn}):not(${validRow}) { pointer-events: none; opacity: 0.5; }`
            );
            scrabbleh.hide();
            submit.show().text("Submit?").addClass("haveCandidate");
            cancel.show().text("Cancel?").addClass("haveCandidate");
          }
        });
      }

      function animateMove(
        originElement,
        destinationElement,
        animationTime = 100
      ) {
        destinationElement.css("visibility", "hidden");
        const original = $(originElement);
        const originalMarginLeft = parseInt(original.css("marginLeft"));
        const originalMarginTop = parseInt(original.css("marginTop"));
        const originPosition = original.position();
        originPosition.left = originPosition.left + originalMarginLeft;
        originPosition.top = originPosition.top + originalMarginTop;
        const originalWidth = original.outerWidth();
        const originalHeight = original.outerHeight();
        const destinationPosition = $(destinationElement).position();
        const destinationWidth = $(destinationElement).outerWidth();
        const destinationHeight = $(destinationElement).outerHeight();
        const temp = original.clone();
        $("body").append(temp).prop("inert", true);
        temp.addClass("temp");
        temp.addClass("disable-hover").find("*").css({ pointerEvents: "none" });
        temp
          .css({
            position: "fixed",
            zIndex: 1,
            width: originalWidth,
            height: originalHeight,
          })
          .offset(originPosition)
          .animate(
            {
              left: destinationPosition.left,
              top: destinationPosition.top,
              width: destinationWidth,
              height: "auto", // destinationHeight,
            },
            animationTime
          );
        setTimeout(() => {
          temp.remove();
          $(destinationElement).css("visibility", "visible");
          $("body").prop("inert", false);
        }, animationTime * 10);
      }

      async function getWordData(word) {
        if (isProfanity(word)) {
          return { isValid: false, firstDefinition: "" };
        }
        const url = `https://api.dictionaryapi.dev/api/v2/entries/en/${word}`;
        return await fetch(url)
          .then((x) => x.json())
          .then((x) => {
            const errorTitle = "No Definitions Found";
            const foundEntry = !("title" in x && x.title.includes(errorTitle));
            const firstDefinition = foundEntry
              ? x[0].meanings[0].definitions[0].definition
              : "";
            return { isValid: foundEntry, firstDefinition: firstDefinition };
          });
      }

      async function setupRealtimeUpdates() {
        const gameID =
          String(gameId.val()).replace(/\D/g, "") || localStorage.gameId;
        if (gameID) {
          await joinGameByCustomId(gameID);
        } else {
          currentGameFirebaseId = await createGame();
          if (playerNumber === "player1") {
            updatePieces(player1Pieces.split(""));
          } else {
            updatePieces(player2Pieces.split(""));
          }
        }
      }

      async function joinGameByCustomId(customId) {
        try {
          const gamesCollection = collection(db, "games");
          const gameQuery = query(gamesCollection, where("id", "==", customId));
          const gameQuerySnapshot = await getDocs(gameQuery);
          if (!gameQuerySnapshot.empty) {
            // Assuming 'id' is unique, there should only be one doc
            if (gameQuerySnapshot.docs.length > 1) {
              console.warn("Multiple games found with the same custom ID.");
            }
            const gameDoc = gameQuerySnapshot.docs[0];
            const gameData = gameDoc.data();
            currentGameFirebaseId = gameDoc.id;
            gameBoardString = gameData.gameBoard;

            bagOfPieces = gameData.bagOfPieces;
            player1Score = gameData.player1Score;
            player2Score = gameData.player2Score;
            player1ScoreInput.val(player1Score);
            player2ScoreInput.val(player2Score);
            player1Pieces = gameData.player1Pieces;
            player2Pieces = gameData.player2Pieces;
            isP1OrP2 =
              localStorage.playerUid === gameData.player1Uid ||
              localStorage.playerUid === gameData.player2Uid ||
              gameData.player2Uid === "";
            const isPlayer1 = localStorage.playerUid === gameData.player1Uid;
            playerNumber = isPlayer1 ? "player1" : "player2";
            updateWhoseTurn(gameData.whoseTurn); // depends on whether player1 already played
            updatePieces(
              isPlayer1 ? player1Pieces.split("") : player2Pieces.split("")
            );

            if (!isP1OrP2) {
              pieces.hide();
              spectator.show();
            } else {
              pieces.show();
              spectator.hide();
              if (isPlayer1) {
                player1ScoreLabel.html("&nbsp;You:");
                player2ScoreLabel.html("&nbsp;P2:");
                player1ScoreInput.addClass("you");
                player2ScoreInput.removeClass("you");
                player1Character.text("You").addClass("you");
                player2Character.text("P2").removeClass("you");
              } else {
                player1ScoreLabel.html("&nbsp;P1:");
                player2ScoreLabel.html("&nbsp;You:");
                player1ScoreInput.removeClass("you");
                player2ScoreInput.addClass("you");
                player1Character.text("P1").removeClass("you");
                player2Character.text("You").addClass("you");
              }
            }

            const canAddPlayer2 = gameData.player2Uid === "";
            if (canAddPlayer2) {
              updateGame(
                currentGameFirebaseId,
                gameBoardString,
                player1Score,
                player2Score,
                player1Pieces,
                player2Pieces,
                whoseTurn,
                isPlayer1 ? localStorage.playerUid : "",
                isPlayer1 ? "" : localStorage.playerUid
              );
            }

            gameId.val(customId);
            formatGameId();
            localStorage.gameId = customId;

            // Setting up real-time updates for the fetched game
            setupRealtimeUpdatesForGameDoc(gameDoc.ref);
          } else {
            console.log("No game found with the custom ID: ", customId);
            gameId.val("");
            localStorage.gameId = "";
            location.reload();
          }
        } catch (error) {
          const errorMessage = "Error fetching game by custom ID: " + error;
          console.error(errorMessage);
          alert(errorMessage);
        }
      }
      function setupRealtimeUpdatesForGameDoc(gameDocRef) {
        onSnapshot(gameDocRef, (docSnapshot) => {
          if (docSnapshot.exists()) {
            const gameData = docSnapshot.data();
            // console.log("Real-time game data: ", gameData);
            bagOfPieces = gameData.bagOfPieces;
            gameBoardString = gameData.gameBoard;
            player1Score = gameData.player1Score;
            player2Score = gameData.player2Score;
            player1ScoreInput.val(player1Score);
            player2ScoreInput.val(player2Score);
            player1Pieces = gameData.player1Pieces;
            player2Pieces = gameData.player2Pieces;
            xy1 = gameData.xy1;
            xy2 = gameData.xy2;
            updateWhoseTurn(gameData.whoseTurn);
            initGameBoard();
            if (xy1 !== "" || xy2 !== "") {
              positionThePlayerCharacters(xy1, xy2);
            }
            if (
              !showingHiddenGame ||
              gameData.xy1 === "" ||
              gameData.xy2 === ""
            ) {
              toggleHiddenGameControls(
                gameData.xy1 !== "" || gameData.xy2 !== ""
              );
              if (gameData.xy1 || gameData.xy2) messageHiddenGame();
            }
          } else {
            console.log("Could not set up real-time updates for a game doc.");
            gameId.val("");
            localStorage.gameId = "";
            location.reload();
          }
        });
      }

      async function createGame() {
        try {
          // Reference to the 'games' collection
          const gamesCollection = collection(db, "games");
          const randomId = getRandomId();
          gameId.val(randomId);
          formatGameId();
          localStorage.gameId = randomId;
          player1Pieces = bagOfPieces.slice(0, 7);
          player2Pieces = bagOfPieces.slice(7, 14);
          bagOfPieces = bagOfPieces.slice(14);
          playerNumber = "player1";
          player1ScoreLabel.html("&nbsp;You:");
          player2ScoreLabel.html("&nbsp;P2:");
          player1ScoreInput.addClass("you");
          player2ScoreInput.removeClass("you");
          player1ScoreInput.val(0);
          player2ScoreInput.val(0);
          player1Character.text("You").addClass("you");
          player2Character.text("P2").removeClass("you");
          updateWhoseTurn(playerNumber);
          // Add a new document with Firestore-generated unique ID
          const gameRef = await addDoc(gamesCollection, {
            id: randomId,
            timestamp: serverTimestamp(),
            player1Uid: localStorage.playerUid,
            player2Uid: "",
            player1Score: 0,
            player2Score: 0,
            player1Pieces: player1Pieces,
            player2Pieces: player2Pieces,
            whoseTurn: whoseTurn, // start the game with player 1 to let the game start faster
            gameBoard: " ".repeat(15 * 15),
            bagOfPieces: bagOfPieces,
            xy1: "",
            xy2: "",
          });
          console.log("Game created with ID: ", gameRef.id);
          return gameRef.id; // Returns the generated game ID
        } catch (error) {
          const errorMessage =
            "Can't create a new game right now. \n\nPlease wait a minute before trying again.";
          pieces.hide();
          gameBoard.hide();
          console.error(errorMessage);
          alert(errorMessage);
        }
      }

      function getRandomId() {
        // assumes people likely won't create a new game a year later at the exact same millisecond
        // this is just a toy project
        return (
          String(getDayOfYear()) + String(getMillisecondsSinceStartOfDay())
        );
      }

      function getDayOfYear() {
        const now = new Date();
        const start = new Date(now.getFullYear(), 0, 0);
        const diff =
          now -
          start +
          (start.getTimezoneOffset() - now.getTimezoneOffset()) * 60 * 1000;
        const oneDay = 1000 * 60 * 60 * 24;
        const dayOfYear = Math.floor(diff / oneDay);
        return dayOfYear;
      }

      function getMillisecondsSinceStartOfDay() {
        const dayStart = new Date();
        dayStart.setHours(0);
        dayStart.setMinutes(0);
        dayStart.setSeconds(0);
        dayStart.setMilliseconds(0);
        return new Date().getTime() - dayStart.getTime();
      }

      async function updateGame(
        currentGameFirebaseId,
        gameBoard,
        player1Score,
        player2Score,
        player1Pieces,
        player2Pieces,
        whoseTurn,
        player1Uid = "",
        player2Uid = ""
      ) {
        const gameRef = doc(db, "games", currentGameFirebaseId);

        let data = {
          id: String(gameId.val()).replace(/\D/g, ""),
          player1Score: player1Score,
          player2Score: player2Score,
          player1Pieces: player1Pieces,
          player2Pieces: player2Pieces,
          whoseTurn: whoseTurn,
          gameBoard: gameBoard,
          bagOfPieces: bagOfPieces,
          xy1: xy1,
          xy2: xy2,
          consumer: consumer,
          // randomTHISSHOULDGETBLOCKED: 123,
        };
        if (player2Uid) {
          data.player2Uid = player2Uid;
        } else {
          data.player1Uid = player1Uid;
        }

        try {
          await updateDoc(gameRef, data);
          console.log("Game updated successfully");
        } catch (error) {
          console.error("Error updating game: ", error);
        }
      }

      async function deleteGame() {
        const gameRef = doc(db, "games", currentGameFirebaseId);

        try {
          await deleteDoc(gameRef);
          console.log(
            `Game with ID ${currentGameFirebaseId} has been deleted.`
          );
        } catch (error) {
          console.error("Error deleting game: ", error);
        }
      }

      async function listenForBroadcasts() {
        try {
          const broadcastCol = collection(db, "broadcast");
          const q = query(broadcastCol);
          const querySnapshot = await getDocs(q);
          const broadcastDoc = querySnapshot.docs[0];
          onSnapshot(broadcastDoc.ref, (docSnapshot) => {
            if (docSnapshot.exists()) {
              const broadcastData = docSnapshot.data();
              // console.log("Real-time broadcast data: ", broadcastData);
              if (String(broadcastData.message).trim()) {
                alert(`Broadcast message: \n\n${broadcastData.message}`);
              }
            } else {
              console.log(
                "Could not set up real-time updates for broadcast doc."
              );
            }
          });
          // Call unsubscribe() when you no longer want to listen to updates
        } catch (error) {
          console.error(error);
        }
      }

      const wordsToBlock = new Set(
        "YWNyb3RvbW9waGlsaWE=|YW5hbA==|YW5pbGluZ3Vz|YW51cw==|YXJzZWhvbGU=|YXNz|YXNzaG9sZQ==|YXNzbXVuY2g=|YXV0b2Vyb3RpYw==|YXV0b2Vyb3RpYw==|YmFiZWxhbmQ=|YmFieWJhdHRlcg==|YmFsbGdhZw==|YmFsbGdyYXZ5|YmFsbGtpY2tpbmc=|YmFsbGxpY2tpbmc=|YmFsbHNhY2s=|YmFsbHN1Y2tpbmc=|YmFuZ2Jyb3M=|YmFyZWJhY2s=|YmFyZWx5bGVnYWw=|YmFyZW5ha2Vk|YmFzdGFyZG8=|YmFzdGluYWRv|YmJ3|YmRzbQ==|YmVhdmVyY2xlYXZlcg==|YmVhdmVybGlwcw==|YmVzdGlhbGl0eQ==|YmljdXJpb3Vz|YmlnYmxhY2s=|YmlnYnJlYXN0cw==|Ymlna25vY2tlcnM=|YmlndGl0cw==|YmltYm9z|YmlyZGxvY2s=|Yml0Y2g=|YmxhY2tjb2Nr|YmxvbmRlYWN0aW9u|YmxvbmRlb25ibG9uZGVhY3Rpb24=|Ymxvd2o=|Ymxvd3lvdXJs|Ymx1ZXdhZmZsZQ==|Ymx1bXBraW4=|Ym9sbG9ja3M=|Ym9uZGFnZQ==|Ym9uZXI=|Ym9vYg==|Ym9vYnM=|Ym9vdHljYWxs|YnJvd25zaG93ZXJz|YnJ1bmV0dGVhY3Rpb24=|YnVra2FrZQ==|YnVsbGR5a2U=|YnVsbGV0dmliZQ==|YnVuZ2hvbGU=|YnVuZ2hvbGU=|YnVzdHk=|YnV0dA==|YnV0dGNoZWVrcw==|YnV0dGhvbGU=|Y2FtZWx0b2U=|Y2FtZ2lybA==|Y2Ftc2x1dA==|Y2Ftd2hvcmU=|Y2FycGV0bXVuY2hlcg==|Y2FycGV0bXVuY2hlcg==|Y2hvY29sYXRlcm9zZWJ1ZHM=|Y2lyY2xlamVyaw==|Y2xldmVsYW5kc3RlYW1lcg==|Y2xpdA==|Y2xpdG9yaXM=|Y2xvdmVyY2xhbXBz|Y2x1c3RlcmZ1Y2s=|Y29jaw==|Y29ja3M=|Y29wcm9sYWduaWE=|Y29wcm9waGlsaWE=|Y29ybmhvbGU=|Y3Vt|Y3VtbWluZw==|Y3VubmlsaW5ndXM=|Y3VudA==|ZGFya2ll|ZGF0ZXJhcGU=|ZGF0ZXJhcGU=|ZGVlcHRocm9hdA==|ZGVlcHRocm9hdA==|ZGljaw==|ZGlsZG8=|ZGlydHlwaWxsb3dz|ZGlydHlzYW5jaGV6|ZG9nc3R5bGU=|ZG9nZ2llc3R5bGU=|ZG9nZ2llc3R5bGU=|ZG9nZ3lzdHlsZQ==|ZG9nZ3lzdHlsZQ==|ZG9sY2V0dA==|ZG9taW5hdGlvbg==|ZG9taW5hdHJpeA==|ZG9tbWVz|ZG9ua2V5cHVuY2g=|ZG91YmxlZG9uZw==|ZG91YmxlcGVuZXRyYXRpb24=|ZHBhY3Rpb24=|ZWF0bXlhc3M=|ZWNjaGk=|ZWphY3VsYXRpb24=|ZXJvdGlj|ZXJvdGlzbQ==|ZXNjb3J0|ZXRoaWNhbHNsdXQ=|ZXVudWNo|ZmFnZ290|ZmVjYWw=|ZmVsY2g=|ZmVsbGF0aW8=|ZmVsdGNo|ZmVtYWxlc3F1aXJ0aW5n|ZmVtZG9t|ZmlnZ2luZw==|ZmluZ2VyaW5n|ZmlzdGluZw==|Zm9vdGZldGlzaA==|Zm9vdGpvYg==|ZnJvdHRpbmc=|ZnVjaw==|ZnVja2J1dHRvbnM=|ZnVkZ2VwYWNrZXI=|ZnVkZ2VwYWNrZXI=|ZnV0YW5hcmk=|Zy1zcG90|Z2FuZ2Jhbmc=|Z2F5c2V4|Z2VuaXRhbHM=|Z2lhbnRjb2Nr|Z2lybG9u|Z2lybG9udG9w|Z2lybHNnb25ld2lsZA==|Z29hdGN4|Z29hdHNl|Z29ra3Vu|Z29sZGVuc2hvd2Vy|Z29vZ2lybA==|Z29vZHBvb3A=|Z29yZWdhc20=|Z3JvcGU=|Z3JvdXBzZXg=|Z3Vybw==|aGFuZGpvYg==|aGFuZGpvYg==|aGFyZGNvcmU=|aGFyZGNvcmU=|aGVudGFp|aG9tb2Vyb3RpYw==|aG9ua2V5|aG9va2Vy|aG90Y2hpY2s=|aG93dG9raWxs|aG93dG9tdXJkZXI=|aHVnZWZhdA==|aHVtcGluZw==|aW5jZXN0|aW50ZXJjb3Vyc2U=|amFja29mZg==|amFpbGJhaXQ=|amFpbGJhaXQ=|amVya29mZg==|amlnYWJvbw==|amlnZ2Fib28=|amlnZ2VyYm9v|aml6eg==|anVnZ3M=|a2lrZQ==|a2luYmFrdQ==|a2lua3N0ZXI=|a2lua3k=|a25vYmJpbmc=|bGVhdGhlcnJlc3RyYWludA==|bGVhdGhlcnN0cmFpZ2h0amFja2V0|bGVtb25wYXJ0eQ==|bG9saXRh|bG92ZW1ha2luZw==|bWFrZW1lY29tZQ==|bWFsZXNxdWlydGluZw==|bWFzdHVyYmF0ZQ==|bWVuYWdlYXRyb2lz|bWlsZg==|bWlzc2lvbmFyeXBvc2l0aW9u|bW90aGVyZnVja2Vy|bW91bmRvZnZlbnVz|bXJoYW5kcw==|bXVmZmRpdmVy|bXVmZmRpdmluZw==|bmFtYmxh|bmF3YXNoaQ==|bmVncm8=|bmVvbmF6aQ==|bmlnbm9n|bmlnZ2E=|bmlnZ2Vy|bmltcGhvbWFuaWE=|bmlwcGxl|bmlwcGxlcw==|bnNmd2ltYWdlcw==|bnVkZQ==|bnVkaXR5|bnltcGhv|bnltcGhvbWFuaWE=|b2N0b3B1c3N5|b21vcmFzaGk=|b25lY3VwdHdvZ2lybHM=|b25lZ3V5b25lamFy|b3JnYXNt|b3JneQ==|cGFlZG9waGlsZQ==|cGFudGllcw==|cGFudHk=|cGVkb2JlYXI=|cGVkb3BoaWxl|cGVnZ2luZw==|cGVuaXM=|cGhvbmVzZXg=|cGllY2VvZnNoaXQ=|cGlzc3BpZw==|cGlzc2luZw==|cGlzc3BpZw==|cGxheWJveQ==|cGxlYXN1cmVjaGVzdA==|cG9sZXNtb2tlcg==|cG9ueXBsYXk=|cG9vZg==|cG9vcGNodXRl|cG9vcGNodXRl|cG9ybg==|cG9ybm8=|cG9ybm9ncmFwaHk=|cHJpbmNlYWxiZXJ0cGllcmNpbmc=|cHRoYw==|cHViZXM=|cHVzc3k=|cXVlYWY=|cmFnaGVhZA==|cmFnaW5nYm9uZXI=|cmFwZQ==|cmFwaW5n|cmFwaXN0|cmVjdHVt|cmV2ZXJzZWNvd2dpcmw=|cmltam9i|cmltbWluZw==|cm9zeXBhbG0=|cnVzdHl0cm9tYm9uZQ==|cyZt|c2FkaXNt|c2NhdA==|c2NobG9uZw==|c2Npc3NvcmluZw==|c2VtZW4=|c2V4|c2V4bw==|c2V4eQ==|c2hhdmVkYmVhdmVy|c2hhdmVkcHVzc3k=|c2hlbWFsZQ==|c2hpYmFyaQ==|c2hpdA==|c2hvdGE=|c2hyaW1waW5n|c2xhbnRleWU=|c2x1dA==|c211dA==|c25hdGNo|c25vd2JhbGxpbmc=|c29kb21pemU=|c29kb215|c3BpYw==|c3Bvb2dl|c3ByZWFkbGVncw==|c3RyYXBvbg==|c3RyYXBvbg==|c3RyYXBwYWRv|c3RyaXBjbHVi|c3R5bGVkb2dneQ==|c3Vjaw==|c3Vja3M=|c3VpY2lkZWdpcmxz|c3VsdHJ5d29tZW4=|c3dhc3Rpa2E=|c3dpbmdlcg==|dGFpbnRlZGxvdmU=|dGFzdGVteQ==|dGVhYmFnZ2luZw==|dGhyZWVzb21l|dGhyb2F0aW5n|dGllZHVw|dGlnaHR3aGl0ZQ==|dGl0|dGl0cw==|dGl0dGllcw==|dGl0dHk=|dG9uZ3VlaW5h|dG9wbGVzcw==|dG9zc2Vy|dG93ZWxoZWFk|dHJhbm55|dHJpYmFkaXNt|dHViZ2lybA==|dHViZ2lybA==|dHVzaHk=|dHdhdA==|dHdpbms=|dHdpbmtpZQ==|dHdvZ2lybHNvbmVjdXA=|dW5kcmVzc2luZw==|dXBza2lydA==|dXJldGhyYXBsYXk=|dXJvcGhpbGlh|dmFnaW5h|dmVudXNtb3VuZA==|dmlicmF0b3I=|dmlvbGV0d2FuZA==|dm9yYXJlcGhpbGlh|dm95ZXVy|dnVsdmE=|d2Fuaw==|d2V0ZHJlYW0=|d2V0YmFjaw==|d2hpdGVwb3dlcg==|d29tZW5yYXBwaW5n|d3JhcHBpbmdtZW4=|d3JpbmtsZWRzdGFyZmlzaA==|eHg=|eHh4|eWFvaQ==|eWVsbG93c2hvd2Vycw==|eWlmZnk=|em9vcGhpbGlh"
          .split("|")
          .map((x) => atob(x))
      );
      function isProfanity(word) {
        return wordsToBlock.has(word.toLowerCase());
      }

      function getRandomInteger(minInclusive, maxInclusive) {
        minInclusive = Math.ceil(minInclusive);
        maxInclusive = Math.floor(maxInclusive);
        const delta = maxInclusive - minInclusive;
        return Math.floor(Math.random() * (delta + 1)) + minInclusive;
      }

      function shuffle(array) {
        // use Fisher-Yates shuffling algorithm:
        function swap(arr, i, j) {
          const temp = arr[i];
          arr[i] = arr[j];
          arr[j] = temp;
        }
        for (let i = 0; i < array.length; i++) {
          // random index from the elements still remaining in the "hat":
          const j = Math.floor(Math.random() * (array.length - i)) + i;
          swap(array, i, j);
        }
        return array;
      }

      function updateWhoseTurn(player) {
        whoseTurn = player;
        // whoseTurn should disable buttons while detecting whether you're player 1 or 2:
        submit
          .add(cancel)
          .add(pieces)
          .add(gameBoard)
          .prop("inert", whoseTurn !== playerNumber || !isP1OrP2);
      }

      window.toggleHiddenGameControls = toggleHiddenGameControls;
      async function toggleHiddenGameControls(show) {
        showingHiddenGame = show;

        // change styling:
        $("body").toggleClass("showingHiddenGame", showingHiddenGame);

        // update wasd controls visibility:
        hiddenGameControls.toggleClass("showing", showingHiddenGame);
        gameBoard.prop("inert", false);

        if (!showingHiddenGame) {
          gameBoard.find(".wall").removeClass("wall").text("");
          // update game board:
          gameBoardString = [...gameBoard.find(".cell")]
            .map((x) => $(x).text() || " ")
            .join("");
        }

        if (showingHiddenGame && !xy1 && !xy2) {
          // need to show/start game:
          const bottomLeft = `0,14`;
          const bottomRight = `14,14`;
          xy1 = bottomLeft;
          xy2 = bottomRight;
          updateHiddenGame(xy1, xy2);
          messageHiddenGame();
        } else if (!showingHiddenGame && xy1 && xy2) {
          // need to hide/stop game:
          xy1 = "";
          xy2 = "";
          updateHiddenGame(xy1, xy2);
        }

        if (showingHiddenGame) {
          if (player1Score < player2Score) {
            consumer = "player1";
            player1Character.addClass("consumer");
            player2Character.removeClass("consumer");
          } else {
            consumer = "player2";
            player1Character.removeClass("consumer");
            player2Character.addClass("consumer");
          }
        }
      }

      async function updateHiddenGame(xy1 = "0,0", xy2 = "0,0") {
        const isPlayer1 = playerNumber === "player1";
        if (isConsumer()) {
          const addedPoints = consumeCellPoints(isPlayer1 ? xy1 : xy2);
          player1Score += isPlayer1 ? addedPoints : 0;
          player2Score += !isPlayer1 ? addedPoints : 0;
        } else {
          capturerCreatesWall(isPlayer1 ? xy1 : xy2);
        }
        try {
          const gameRef = doc(db, "games", currentGameFirebaseId);
          const data = {
            id: String(gameId.val()).replace(/\D/g, ""),
            player1Score: player1Score,
            player2Score: player2Score,
            player1Pieces: player1Pieces,
            player2Pieces: player2Pieces,
            whoseTurn: whoseTurn,
            gameBoard: gameBoardString,
            bagOfPieces: bagOfPieces,
            xy1: showingHiddenGame ? xy1 : "",
            xy2: showingHiddenGame ? xy2 : "",
            consumer: consumer,
          };
          await updateDoc(gameRef, data);
          console.log("Hidden game updated successfully");

          positionThePlayerCharacters(xy1, xy2);

          player1ScoreInput.val(player1Score);
          player2ScoreInput.val(player2Score);

          player1Character.toggleClass("consumer", consumer === "player1");
          player2Character.toggleClass("consumer", consumer === "player2");
        } catch (error) {
          console.error("Error updating hidden game: ", error);
        }

        const caughtConsumer = xy1 === xy2 && xy1 !== "" && xy2 !== "";
        const nothingToConsume = !gameBoard.find(".cell:not(:empty)").length;
        if (caughtConsumer || nothingToConsume) {
          xy1 = "";
          xy2 = "";
          toggleHiddenGameControls(false); // watch out that this doesn't cause infinite loop
          updateWhoseTurn(whoseTurn); // in case need to undo gameBoard.prop("inert", false);
        }
      }

      function isConsumer() {
        return playerNumber === "player1"
          ? consumer === "player1"
          : consumer === "player2";
      }

      function consumeCellPoints(xCommaY) {
        const [x, y] = xCommaY.split(",");
        const cell = cellAtXY(Number(x), Number(y));
        const cellText = cell.text();
        const consumablePoints = cellText ? piecePoints[cellText] : 0;
        if (consumablePoints && isConsumer()) {
          cell.text("");
          // update game board:
          gameBoardString = [...gameBoard.find(".cell")]
            .map((x) => $(x).text() || " ")
            .join("");
        }
        return consumablePoints;
      }

      function capturerCreatesWall(xCommaY) {
        const [x, y] = xCommaY.split(",");
        const cell = cellAtXY(Number(x), Number(y));
        const cellText = cell.text();
        if (consumer !== "" && !isConsumer() && !cellText) {
          cell.text(wall).addClass("wall");
          // update game board:
          gameBoardString = [...gameBoard.find(".cell")]
            .map((x) => $(x).text() || " ")
            .join("");
        }
      }

      function cellAtXY(x, y) {
        const i = 15 * y + x;
        return gameBoard.find(`.cell[data-i="${i}"]`);
      }

      function isWall(xyNew) {
        const [x, y] = xyNew.split(",").map((val) => Number(val));
        return cellAtXY(x, y).text() === wall;
      }

      function positionThePlayerCharacters(xy1, xy2) {
        const xy1New = xy1.split(",").map((v) => minMax(0, Number(v), 14));
        const xy2New = xy2.split(",").map((v) => minMax(0, Number(v), 14));

        const delta = Number($(".cell").css("width").replace("px", ""));

        player1Character.css({
          transform: `translate(${Number(xy1New[0]) * delta}px, ${
            Number(xy1New[1]) * delta
          }px)`,
        });

        player2Character.css({
          transform: `translate(${Number(xy2New[0]) * delta}px, ${
            Number(xy2New[1]) * delta
          }px)`,
        });
      }

      function minMax(min, n, max) {
        if (n < min) return min;
        if (n > max) return max;
        return n;
      }

      function initHiddenGameControls() {
        $("body").on("keypress", (event) => {
          if (showingHiddenGame) {
            switch (event.key) {
              case "w":
                hiddenGameControls.find("#w").click();
                break;
              case "a":
                hiddenGameControls.find("#a").click();
                break;
              case "s":
                hiddenGameControls.find("#s").click();
                break;
              case "d":
                hiddenGameControls.find("#d").click();
                break;
            }
          }
        });
        let motionTimeout = null;
        hiddenGameControls.find("#w").on("click", () => {
          if (showingHiddenGame && !motionTimeout) {
            motionTimeout = setTimeout(() => {
              motionTimeout = null;
            }, 100);
            let xyNew = playerNumber === "player1" ? xy1 : xy2;
            xyNew = xyNew.split(",");
            xyNew[1] = minMax(0, (Number(xyNew[1]) || 0) - 1, 14);
            xyNew = xyNew.join(",");
            if (!isWall(xyNew) || !isConsumer()) {
              xy1 = playerNumber === "player1" ? xyNew : xy1;
              xy2 = playerNumber === "player1" ? xy2 : xyNew;
              updateHiddenGame(xy1, xy2);
            }
          }
        });
        hiddenGameControls.find("#a").on("click", () => {
          if (showingHiddenGame && !motionTimeout) {
            motionTimeout = setTimeout(() => {
              motionTimeout = null;
            }, 100);
            let xyNew = playerNumber === "player1" ? xy1 : xy2;
            xyNew = xyNew.split(",");
            xyNew[0] = minMax(0, Number(xyNew[0]) - 1, 14);
            xyNew = xyNew.join(",");
            if (!isWall(xyNew) || !isConsumer()) {
              xy1 = playerNumber === "player1" ? xyNew : xy1;
              xy2 = playerNumber === "player1" ? xy2 : xyNew;
              updateHiddenGame(xy1, xy2);
            }
          }
        });
        hiddenGameControls.find("#s").on("click", () => {
          if (showingHiddenGame && !motionTimeout) {
            motionTimeout = setTimeout(() => {
              motionTimeout = null;
            }, 100);
            let xyNew = playerNumber === "player1" ? xy1 : xy2;
            xyNew = xyNew.split(",");
            xyNew[1] = minMax(0, (Number(xyNew[1]) || 0) + 1, 14);
            xyNew = xyNew.join(",");
            if (!isWall(xyNew) || !isConsumer()) {
              xy1 = playerNumber === "player1" ? xyNew : xy1;
              xy2 = playerNumber === "player1" ? xy2 : xyNew;
              updateHiddenGame(xy1, xy2);
            }
          }
        });
        hiddenGameControls.find("#d").on("click", () => {
          if (showingHiddenGame && !motionTimeout) {
            motionTimeout = setTimeout(() => {
              motionTimeout = null;
            }, 100);
            let xyNew = playerNumber === "player1" ? xy1 : xy2;
            xyNew = xyNew.split(",");
            xyNew[0] = minMax(0, Number(xyNew[0]) + 1, 14);
            xyNew = xyNew.join(",");
            if (!isWall(xyNew) || !isConsumer()) {
              xy1 = playerNumber === "player1" ? xyNew : xy1;
              xy2 = playerNumber === "player1" ? xy2 : xyNew;
              updateHiddenGame(xy1, xy2);
            }
          }
        });
      }

      function getPointsToAdd() {
        // assumes board validation has already been done

        let addedPoints = 0;

        let currentWordPoints = 0;

        // part 1: calculate the candidate letters and opacity 1 letters connected to them:

        const multipliers = new Set(["x3W", "x2W", "x3L", "x2L"]);
        let wordMultiplier = 1;
        gameBoard.find(".candidate").each((i, el) => {
          const cell = $(el);
          const letter = cell.text();
          let letterPoints = piecePoints[letter];
          const multiplier = multipliers.has(cell[0].classList[1])
            ? cell[0].classList[1]
            : "";
          if (multiplier === "x3W") wordMultiplier *= 3;
          if (multiplier === "x2W") wordMultiplier *= 2;
          if (multiplier === "x3L") letterPoints *= 3;
          if (multiplier === "x2L") letterPoints *= 2;
          currentWordPoints += letterPoints;
        });
        // opacity 1 letters connected to .candidate letters
        const opacity1Letters = gameBoard
          .find(".cell")
          .filter(
            (i, el) =>
              $(el).css("opacity") === "1" &&
              $(el).text() &&
              !$(el).hasClass("candidate")
          );
        opacity1Letters.each((i, el) => {
          const index = $(el).data("i");
          const letter = $(el).text();
          let found = false;
          let up = getIndexUp(index);
          while (!found && $(`.cell[data-i="${up}"]`).text()) {
            if ($(`.cell[data-i="${up}"]`).is(".candidate")) {
              found = true;
              break;
            }
            up = getIndexUp(up);
          }
          let down = getIndexDown(index);
          while (!found && $(`.cell[data-i="${down}"]`).text()) {
            if ($(`.cell[data-i="${down}"]`).is(".candidate")) {
              found = true;
              break;
            }
            down = getIndexDown(down);
          }
          let left = getIndexLeft(index);
          while (!found && $(`.cell[data-i="${left}"]`).text()) {
            if ($(`.cell[data-i="${left}"]`).is(".candidate")) {
              found = true;
              break;
            }
            left = getIndexLeft(left);
          }
          let right = getIndexRight(index);
          while (!found && $(`.cell[data-i="${right}"]`).text()) {
            if ($(`.cell[data-i="${right}"]`).is(".candidate")) {
              found = true;
              break;
            }
            right = getIndexRight(right);
          }
          if (found) {
            currentWordPoints += piecePoints[letter];
          }
        });
        currentWordPoints *= wordMultiplier;

        addedPoints += currentWordPoints;

        // part 2: intersections too:

        currentWordPoints = 0;

        gameBoard.find(".candidate").each((i, el) => {
          wordMultiplier = 1;

          const cell = $(el);
          const letter = cell.text();
          let letterPoints = piecePoints[letter];
          const multiplier = multipliers.has(cell[0].classList[1])
            ? cell[0].classList[1]
            : "";
          if (multiplier === "x3W") wordMultiplier *= 3;
          if (multiplier === "x2W") wordMultiplier *= 2;
          if (multiplier === "x3L") letterPoints *= 3;
          if (multiplier === "x2L") letterPoints *= 2;

          let foundIntersection = false;

          const index = $(el).data("i");
          let up = getIndexUp(index);
          while (
            $(`.cell[data-i="${up}"]`).text() &&
            $(`.cell[data-i="${up}"]`).css("opacity") !== "1"
          ) {
            foundIntersection = true;
            letterPoints += piecePoints[$(`.cell[data-i="${up}"]`).text()];
            up = getIndexUp(up);
          }
          let down = getIndexDown(index);
          while (
            $(`.cell[data-i="${down}"]`).text() &&
            $(`.cell[data-i="${down}"]`).css("opacity") !== "1"
          ) {
            foundIntersection = true;
            letterPoints += piecePoints[$(`.cell[data-i="${down}"]`).text()];
            down = getIndexDown(down);
          }
          let left = getIndexLeft(index);
          while (
            $(`.cell[data-i="${left}"]`).text() &&
            $(`.cell[data-i="${left}"]`).css("opacity") !== "1"
          ) {
            foundIntersection = true;
            letterPoints += piecePoints[$(`.cell[data-i="${left}"]`).text()];
            left = getIndexLeft(left);
          }
          let right = getIndexRight(index);
          while (
            $(`.cell[data-i="${right}"]`).text() &&
            $(`.cell[data-i="${right}"]`).css("opacity") !== "1"
          ) {
            foundIntersection = true;
            letterPoints += piecePoints[$(`.cell[data-i="${right}"]`).text()];
            right = getIndexRight(right);
          }

          if (foundIntersection) {
            currentWordPoints += letterPoints * wordMultiplier;
          }
        });

        addedPoints += currentWordPoints;

        return addedPoints;
      }

      function messageHiddenGame() {
        const isPlayer1 = playerNumber === "player1";
        const otherPlayer = `Player ${isPlayer1 ? "2" : "1"}`;
        if (isConsumer()) {
          alert(
            `Eh? The hidden game has been triggered!\n\nYou can eat letters to get extra points before ${otherPlayer} catches you!`
          );
        } else {
          alert(
            `Eh? The hidden game has been triggered!\n\n${otherPlayer} can eat letters to get extra points before you catch them!`
          );
        }
      }
    </script>
  </body>
</html>
